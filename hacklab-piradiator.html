<!DOCTYPE html PUBLIC
	  "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="fi" xml:lang="fi">
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Language" content="fi-fi" />
    <meta name="ROBOTS" content="NOINDEX, NOFOLLOW" />
    <title>EtherPad: hacklab-piradiator / Latest text of pad hacklab-piradiator</title>
    <base href="" />

    <!-- CSS -->
    <link href="http://www.kirjoitusalusta.fi/static/compressed/b551c5e3fb39001db66e471d65b43e1d.css" rel="stylesheet" type="text/css" />

    
<style type="text/css" title="dynamicsyntax"></style>


    <!-- javascript -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17968704-1']);
  _gaq.push(['_setDomainName', '.kirjoitusalusta.fi']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


    <script type="text/javascript">
  // <![CDATA[
var clientVars = {"historicalAuthorData":{"g.ol3rfryrn1d3up6k":{"colorId":13,"name":"Jssmk"},"g.kpkftayxs0ote5ov":{"colorId":14},"g.9hgz6yehdlrhqtp0":{"colorId":9,"name":"jari"},"g.7zpvaea8xn6r2bur":{"colorId":5,"name":"jautero"},"g.7adqe1th72vgygl8":{"colorId":10,"name":"zzorn"},"g.s2bud5tbeqc1y5gb":{"colorId":23,"name":"suovula"},"g.w7tn8zpk3k1bda17":{"colorId":9,"name":"jautero"},"g.5jvpgsdx3x2ya08l":{"colorId":22,"name":"anacron"},"g.pyauz2yciq1lccie":{"colorId":20,"name":"Harald"},"g.deyasmhbmx36psyp":{"colorId":30},"g.jehs2sxyawquxqby":{"colorId":18,"name":"jautero"},"g.fnqi1hq94in75987":{"colorId":25,"name":"Dezgeg"},"g.moj83bmsetvjbxa6":{"colorId":31},"g.fgbk65v1gwktdgo5":{"colorId":5},"g.l818624df9bjygkz":{"colorId":28,"name":"Harald"}},"totalRevs":93,"hooks":{},"disableRightBar":false,"revNum":93,"initialStyledContents":{"atext":{"text":"/*\n    For OpenGL ES 2.0 programming:\n*    http://benosteen.wordpress.com/2012/04/27/using-opengl-es-2-0-on-the-raspberry-pi-without-x-windows/\n*/\n\n\n\n/*\nInformation radiator for raspberry PI.\n\nCompile with \ng++ -o piradiator piradiator.cpp -lSDL -lSDL_gfx\n\n*/\n\n#include \"SDL/SDL.h\" \n#include \"SDL/SDL_gfxPrimitives.h\" \n#include \x3cstring>\n#include \x3cstdlib.h>\n#include \x3ctime.h>\n#include \x3cctime>\n\n//Screen attributes \nconst int SCREEN_WIDTH = 800; \nconst int SCREEN_HEIGHT = 240; \nconst int SCREEN_BPP = 32; \n\nconst int SPEED = 100; \n\nSDL_Surface *screen = NULL;\n\nSDL_Event event;\n\nconst int DISPLAY_W = 48; \nconst int DISPLAY_H = 9; \n\nconst int DISPLAY_PIXEL_W = SCREEN_WIDTH / DISPLAY_W; \nconst int DISPLAY_PIXEL_H = SCREEN_HEIGHT / DISPLAY_H; \n\nconst int DISPLAY_SIZE = DISPLAY_W * DISPLAY_H;\nint display[DISPLAY_SIZE];\nint display2[DISPLAY_SIZE];\n\nconst int CHAR_W = 5; \nconst int CHAR_H = 7; \n\nint oldSecond = -1;\n\nint char0[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char1[] = {0, 0, 1, 0, 0,\n                 0, 1, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0 };\n\nint char2[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 1, 0, 0, 0,\n   1, 1, 1, 1, 1 }; \n\nint char3[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char4[] = \n  {1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1 }; \n\nint char5[] = \n  {1, 1, 1, 1, 1,\n   1, 0, 0, 0, 0,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char6[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char7[] = \n  {1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0 }; \n\nint char8[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char9[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint charColon[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nint charSpace[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nint charInvader1[] = \n  {1, 0, 0, 0, 1,\n   0, 1, 0, 1, 0,\n   1, 1, 1, 1, 1,\n   1, 0, 1, 0, 1,\n   1, 1, 1, 1, 1,\n   1, 0, 0, 0, 1,\n   1, 1, 0, 1, 1 }; \n\nbool init() { \n  // Init SDL\n  if (SDL_Init(SDL_INIT_EVERYTHING) == -1) { \n    return false; \n  } \n\n  // Set up the screen \n  screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, SDL_SWSURFACE); \n\n  // If there was an error in setting up the screen \n  if (screen == NULL) { return false; } \n\n  // Set the window caption \n  SDL_WM_SetCaption(\"PiRadiator\", NULL); \n\n  // Init display\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display[i] = 0;\n  } \n\n  // Init random\n  srand(time(NULL)); \n\n  // If everything initialized fine \n  return true; \n}\n\nvoid load_files() {\n}\n\nvoid clean_up() { \n   SDL_Quit(); \n}\n\n\nint clampZeroTo255(int v) {\n  if (v \x3c 0) return 0;\n  else if (v > 255) return 255;\n  else return v;\n}\n\nint colorRgb(int r, int g, int b) {\n  return SDL_MapRGB(screen->format, r, g, b);\n}\n\nint colorRgba(int r, int g, int b, int a) {\n  return SDL_MapRGBA(screen->format, r, g, b, a);\n}\n\nvoid fillRect(int x, int y, int w, int h, int color) {\n  SDL_Rect rect = {x,y,w,h};\n  SDL_FillRect(screen, &rect, color);\n}\n\n\nvoid drawDisplayPixel(int x, int y, int color) {  \n\n  int r = (color >> 24) & 0xFF;\n  int g = (color >> 16) & 0xFF;\n  int b = (color >> 8) & 0xFF;\n  int a = (color >> 0) & 0xFF;\n\n  int x1 = x * DISPLAY_PIXEL_W;\n  int y1 = y * DISPLAY_PIXEL_H;\n  int x2 = x1 + DISPLAY_PIXEL_W;\n  int y2 = y1 + DISPLAY_PIXEL_H;\n\n  int w = DISPLAY_PIXEL_W / 2;\n  int h = DISPLAY_PIXEL_H / 2;\n\n\n  int lum1 = 50;\n  int lum2 = 80;\n  int lum3 = 100;\n\n  int border1 = 1;\n  int border2 = 2;\n  int border3 = 4;\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border1, h-border1, r*lum1/100, g*lum1/100, b*lum1/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border2, h-border2, r*lum2/100, g*lum2/100, b*lum2/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border3, h-border3, r*lum3/100, g*lum3/100, b*lum3/100, 255);\n}\n\nint makeDisplayColor(int r, int g, int b, int a) {\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n\n    return (r \x3c\x3c 24) | (g \x3c\x3c 16) | (b \x3c\x3c 8) | (a);\n}\n\nvoid setPixel(int x, int y, int r, int g, int b, int a) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = makeDisplayColor(r, g, b, a);\n  }   \n}\n\nvoid setPixelColor(int x, int y, int color) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = color;\n  }   \n}\n\nvoid clearDisplay(int r, int g, int b, int a) {\n  int color = makeDisplayColor(r, g, b, a);\n\n  for (int i = 0; i \x3c DISPLAY_W * DISPLAY_H; i++) {\n    display[i] = color;\n  }\n}\n\nint getSecond() {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  return ltm->tm_sec;\n}\n\n\nvoid clearScreen(int color) {\n  SDL_FillRect(screen, NULL, color);\n}\n\n\nvoid drawDisplay() {\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      int col = display[y * DISPLAY_W + x];\n      if (col != 0) {\n        drawDisplayPixel(x, y, col);\n      }\n    }\n  }\n}\n\nvoid writeSprite(int xp, int yp, int *pic, int w, int h, int r, int g, int b, int a) {\n\n  int col = makeDisplayColor(r, g, b, a);\n\n  for (int y = yp; y \x3c yp + h; y++) {\n    for (int x = xp; x \x3c xp + w; x++) {\n      int idx = (y - yp) * w + (x - xp);\n      if (pic[idx] > 0) setPixelColor(x, y, col);\n    }\n  } \n}\n\nvoid writeChar(int x, int y, int r, int g, int b, int a, char c, bool invaders) {\n  int col = makeDisplayColor(r, g, b, a);\n\n  if (invaders && getSecond() == x / 5) {\n    c = '*';\n  }\n\n\n  switch (c) {\n    case '0': writeSprite(x, y, char0, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '1': writeSprite(x, y, char1, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '2': writeSprite(x, y, char2, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '3': writeSprite(x, y, char3, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '4': writeSprite(x, y, char4, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '5': writeSprite(x, y, char5, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '6': writeSprite(x, y, char6, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '7': writeSprite(x, y, char7, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '8': writeSprite(x, y, char8, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '9': writeSprite(x, y, char9, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ':': writeSprite(x, y, charColon, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ' ': writeSprite(x, y, charSpace, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '*': writeSprite(x, y, charInvader1, CHAR_W, CHAR_H, r, g, b, a); break;\n    default: ;\n  }\n}\n\nvoid writeNumber(int x, int y, int r, int g, int b, int a, int num, int digits, int spacing, bool invaders) {\n  bool numEncountered = false; \n  int xPos = x;\n  for (int digit = digits - 1; digit >= 0; digit--) {\n    int divider = 1;\n    for (int i = 0; i \x3c digit; i++) {\n      divider *= 10;\n    }\n\n    int d = (num / divider) % 10;         \n    numEncountered = numEncountered || (d != 0);\n\n    char ch = '0' + d;\n\n \n\n    /* Uncomment to skip leading zeroes\n    if (numEncountered || digit == 0) {\n    */\n      writeChar(xPos, y, r, g, b, a, ch, invaders);\n    /*\n    }\n    */\n \n    xPos += CHAR_W + spacing;\n  }\n}\n\n\n// ---------\n\nvoid move(int dx, int dy) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display2[i] = display[i];\n  }\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      setPixelColor(x + dx, y + dy, display2[y * DISPLAY_W + x]);\n    }\n  }\n}\n\nvoid fade(int fadeAmount) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    int color = display[i];\n    int r =  (color >> 24) & 0xFF;\n    int g =  (color >> 16) & 0xFF;\n    int b =  (color >> 8) & 0xFF;\n    int a =  (color >> 0) & 0xFF;\n    r = r * fadeAmount / 100;    \n    g = g * fadeAmount / 100;    \n    b = b * fadeAmount / 100;\n    a = 255;\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n    display[i] = ((r & 0xFF) \x3c\x3c 24) | ((g & 0xFF) \x3c\x3c 16) | ((b & 0xFF) \x3c\x3c 8) | ((a & 0xFF) \x3c\x3c 0);   \n  }    \n}\n\nbool invaders = false;\n\nvoid writeTime(int x, int y, int r, int g, int b, int a) {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  \n  // Check if we got invaded\n  if ((rand() % 100) \x3c= 1) {\n    invaders = true;\n  }\n  if ((rand() % 100) \x3c= 20) {\n    invaders = false;\n  }\n  if (ltm->tm_hour > 3 && ltm->tm_hour \x3c 7 && (rand() % 100) \x3c 20) {\n    invaders = true;\n  }\n\n  int spacing = 2;\n  int numW = CHAR_W * 2 + spacing;\n  int xPos = x;\n  int digits = 2;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_hour, digits, spacing, invaders);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':', false);\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_min, digits, spacing, invaders);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':', false);\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_sec, digits, spacing, invaders);\n}\n\nint tr = 255;\nint tg = 0;\nint tb = 0;\n\nvoid update(int timeDelta, long totalTime, long frameCount) {\n\n  // Fadeout\n  //boxRGBA(screen, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0,0,0, 10);\n  move(0, 1);\n  fade(35);\n\n  int second = getSecond();  \n  if (oldSecond != second) { \n    oldSecond = second;\n  \n    // Change color\n    int delta = 100;\n    \n    tr += (rand() % delta) - delta/2; \n    tg += (rand() % delta) - delta/2; \n    tb += (rand() % delta) - delta/2; \n\n    tr = clampZeroTo255(tr);\n    tg = clampZeroTo255(tg);\n    tb = clampZeroTo255(tb);\n\n    // Avoid going too dark \n    if (tr + tg + tb \x3c 150) {\n      if ((rand() % 100) \x3c 30) tr = 255;\n      else if ((rand() % 100) \x3c 50) tg = 255;\n      else tb = 255;\n    }\n  }\n\n  int x = 2;\n  int y = 1;\n  writeTime(x, y, tr, tg, tb, 255);\n}\n\n\n\n// ----------\n\nint main( int argc, char* args[] ) { \n\n  long totalTime = 0;\n  long frameCount = 0;\n\n  // Initialize\n  if (!init()) return 1;\n\n  load_files();\n\n  // Clear existing pixels to transparent\n  clearDisplay(0,0,0,0);\n\n  // Loop  \n  bool quit = false;\n  while( quit == false ) {\n    \n    //Update Screen \n    SDL_Flip(screen); \n  \n    //Pause \n    usleep(SPEED * 1000);\n\n    // Check input\n    while (SDL_PollEvent(&event)) {\n\n      // Check for close button press \n      if (event.type == SDL_QUIT) { \n        quit = true; \n      } \n    }\n\n    // Update\n    totalTime += SPEED;\n    frameCount++;\n    update(SPEED, totalTime, frameCount);  \n\n    // Draw\n    drawDisplay();\n\n  }\n\n  clean_up();\n  return 0; \n}\n\n\n\n\n","attribs":"|2+12*0*1+1|2+30*2|3+3*3|ed+8j8|1+1"},"historicalAuthorData":{"g.s2bud5tbeqc1y5gb":{"colorId":23,"name":"suovula"},"g.fgbk65v1gwktdgo5":{"colorId":5}},"apool":{"numToAttrib":{"0":["insertorder","first"],"1":["list","bullet1"],"2":["author","g.s2bud5tbeqc1y5gb"],"3":["author","g.fgbk65v1gwktdgo5"]},"nextNum":4}},"viewId":"hacklab-piradiator","fullWidth":false,"initialChangesets":[{"start":0,"forwardsChangesets":[],"timeDeltas":[],"granularity":100,"actualEndNum":0,"apool":{"numToAttrib":{},"nextNum":0},"backwardsChangesets":[]},{"start":0,"forwardsChangesets":["Z:1>1b*0|1+e*0+u|1+1*0|1+1*0+1$Compile with \ng++ -o pidemo pidemo.cpp -lSDL\n\nC","Z:1c>a5|3=1a=1*0|2+j|1+1*0|l+9j*0+1|1+1$ode (pidemo.cpp):\n\n\n#include \"SDL/SDL.h\" \n\nint main( int argc, char* args[] ) { \n  SDL_Surface* screen = NULL;\n\n  //Start SDL \n  SDL_Init( SDL_INIT_EVERYTHING ); \n\n //Set up screen\n  screen = SDL_SetVideoMode( 1024, 320, 32, SDL_SWSURFACE ); \n\n  //Update Screen \n  SDL_Flip(screen); \n  \n  //Pause \n  SDL_Delay(2000);\n\n  //Quit SDL \n  SDL_Quit(); \n  \n  return 0; \n}\n","Z:bh>3*0|1+3$/*\n","Z:bk\x3cbj|t-bj$","Z:1>7ug*1|d8+7ug$/*\nInformation radiator for raspberry PI.\n\nCompile with \ng++ -o piradiator piradiator.cpp -lSDL -lSDL_gfx\n\n*/\n\n#include \"SDL/SDL.h\" \n#include \"SDL/SDL_gfxPrimitives.h\" \n#include \x3cstring>\n#include \x3cstdlib.h>\n#include \x3ctime.h>\n#include \x3cctime>\n\n//Screen attributes \nconst int SCREEN_WIDTH = 800; \nconst int SCREEN_HEIGHT = 240; \nconst int SCREEN_BPP = 32; \n\nconst int SPEED = 100; \n\nSDL_Surface *screen = NULL;\n\nSDL_Event event;\n\nconst int DISPLAY_W = 48; \nconst int DISPLAY_H = 9; \n\nconst int DISPLAY_PIXEL_W = SCREEN_WIDTH / DISPLAY_W; \nconst int DISPLAY_PIXEL_H = SCREEN_HEIGHT / DISPLAY_H; \n\nconst int DISPLAY_SIZE = DISPLAY_W * DISPLAY_H;\nint display[DISPLAY_SIZE];\nint display2[DISPLAY_SIZE];\n\nconst int CHAR_W = 5; \nconst int CHAR_H = 7; \n\nint oldSecond = -1;\n\nint char0[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char1[] = {0, 0, 1, 0, 0,\n                 0, 1, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0 };\n\nint char2[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 1, 0, 0, 0,\n   1, 1, 1, 1, 1 }; \n\nint char3[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char4[] = \n  {1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1 }; \n\nint char5[] = \n  {1, 1, 1, 1, 1,\n   1, 0, 0, 0, 0,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char6[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char7[] = \n  {1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0 }; \n\nint char8[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char9[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint charColon[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nint charSpace[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nbool init() { \n  // Init SDL\n  if (SDL_Init(SDL_INIT_EVERYTHING) == -1) { \n    return false; \n  } \n\n  // Set up the screen \n  screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, SDL_SWSURFACE); \n\n  // If there was an error in setting up the screen \n  if (screen == NULL) { return false; } \n\n  // Set the window caption \n  SDL_WM_SetCaption(\"PiRadiator\", NULL); \n\n  // Init display\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display[i] = 0;\n  } \n\n  // Init random\n  srand(time(NULL)); \n\n  // If everything initialized fine \n  return true; \n}\n\nvoid load_files() {\n}\n\nvoid clean_up() { \n   SDL_Quit(); \n}\n\n\nint clampZeroTo255(int v) {\n  if (v \x3c 0) return 0;\n  else if (v > 255) return 255;\n  else return v;\n}\n\nint colorRgb(int r, int g, int b) {\n  return SDL_MapRGB(screen->format, r, g, b);\n}\n\nint colorRgba(int r, int g, int b, int a) {\n  return SDL_MapRGBA(screen->format, r, g, b, a);\n}\n\nvoid fillRect(int x, int y, int w, int h, int color) {\n  SDL_Rect rect = {x,y,w,h};\n  SDL_FillRect(screen, &rect, color);\n}\n\n\nvoid drawDisplayPixel(int x, int y, int color) {  \n\n  int r = (color >> 24) & 0xFF;\n  int g = (color >> 16) & 0xFF;\n  int b = (color >> 8) & 0xFF;\n  int a = (color >> 0) & 0xFF;\n\n  int x1 = x * DISPLAY_PIXEL_W;\n  int y1 = y * DISPLAY_PIXEL_H;\n  int x2 = x1 + DISPLAY_PIXEL_W;\n  int y2 = y1 + DISPLAY_PIXEL_H;\n\n  int w = DISPLAY_PIXEL_W / 2;\n  int h = DISPLAY_PIXEL_H / 2;\n\n\n  int lum1 = 50;\n  int lum2 = 80;\n  int lum3 = 100;\n\n  int border1 = 1;\n  int border2 = 2;\n  int border3 = 4;\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border1, h-border1, r*lum1/100, g*lum1/100, b*lum1/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border2, h-border2, r*lum2/100, g*lum2/100, b*lum2/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border3, h-border3, r*lum3/100, g*lum3/100, b*lum3/100, 255);\n}\n\nint makeDisplayColor(int r, int g, int b, int a) {\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n\n    return (r \x3c\x3c 24) | (g \x3c\x3c 16) | (b \x3c\x3c 8) | (a);\n}\n\nvoid setPixel(int x, int y, int r, int g, int b, int a) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = makeDisplayColor(r, g, b, a);\n  }   \n}\n\nvoid setPixelColor(int x, int y, int color) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = color;\n  }   \n}\n\nvoid clearDisplay(int r, int g, int b, int a) {\n  int color = makeDisplayColor(r, g, b, a);\n\n  for (int i = 0; i \x3c DISPLAY_W * DISPLAY_H; i++) {\n    display[i] = color;\n  }\n}\n\nvoid clearScreen(int color) {\n  SDL_FillRect(screen, NULL, color);\n}\n\n\nvoid drawDisplay() {\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      int col = display[y * DISPLAY_W + x];\n      if (col != 0) {\n        drawDisplayPixel(x, y, col);\n      }\n    }\n  }\n}\n\nvoid writeSprite(int xp, int yp, int *pic, int w, int h, int r, int g, int b, int a) {\n\n  int col = makeDisplayColor(r, g, b, a);\n\n  for (int y = yp; y \x3c yp + h; y++) {\n    for (int x = xp; x \x3c xp + w; x++) {\n      int idx = (y - yp) * w + (x - xp);\n      if (pic[idx] > 0) setPixelColor(x, y, col);\n    }\n  } \n}\n\nvoid writeChar(int x, int y, int r, int g, int b, int a, char c) {\n  int col = makeDisplayColor(r, g, b, a);\n\n  switch (c) {\n    case '0': writeSprite(x, y, char0, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '1': writeSprite(x, y, char1, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '2': writeSprite(x, y, char2, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '3': writeSprite(x, y, char3, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '4': writeSprite(x, y, char4, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '5': writeSprite(x, y, char5, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '6': writeSprite(x, y, char6, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '7': writeSprite(x, y, char7, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '8': writeSprite(x, y, char8, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '9': writeSprite(x, y, char9, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ':': writeSprite(x, y, charColon, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ' ': writeSprite(x, y, charSpace, CHAR_W, CHAR_H, r, g, b, a); break;\n    default: ;\n  }\n}\n\nvoid writeNumber(int x, int y, int r, int g, int b, int a, int num, int digits, int spacing) {\n  bool numEncountered = false; \n  int xPos = x;\n  for (int digit = digits - 1; digit >= 0; digit--) {\n    int divider = 1;\n    for (int i = 0; i \x3c digit; i++) {\n      divider *= 10;\n    }\n\n    int d = (num / divider) % 10;         \n    numEncountered = numEncountered || (d != 0);\n\n    /* Uncomment to skip leading zeroes\n    if (numEncountered || digit == 0) {\n    */\n      writeChar(xPos, y, r, g, b, a, '0' + d);\n    /*\n    }\n    */\n \n    xPos += CHAR_W + spacing;\n  }\n}\n\n\n// ---------\n\nvoid move(int dx, int dy) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display2[i] = display[i];\n  }\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      setPixelColor(x + dx, y + dy, display2[y * DISPLAY_W + x]);\n    }\n  }\n}\n\nvoid fade(int fadeAmount) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    int color = display[i];\n    int r =  (color >> 24) & 0xFF;\n    int g =  (color >> 16) & 0xFF;\n    int b =  (color >> 8) & 0xFF;\n    int a =  (color >> 0) & 0xFF;\n    r = r * fadeAmount / 100;    \n    g = g * fadeAmount / 100;    \n    b = b * fadeAmount / 100;\n    a = 255;\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n    display[i] = ((r & 0xFF) \x3c\x3c 24) | ((g & 0xFF) \x3c\x3c 16) | ((b & 0xFF) \x3c\x3c 8) | ((a & 0xFF) \x3c\x3c 0);   \n  }    \n}\n\nint getSecond() {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  return ltm->tm_sec;\n}\n\nvoid writeTime(int x, int y, int r, int g, int b, int a) {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  \n  int spacing = 2;\n  int numW = CHAR_W * 2 + spacing;\n  int xPos = x;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_hour, 2, spacing);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':');\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_min, 2, spacing);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':');\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_sec, 2, spacing);\n}\n\nint tr = 255;\nint tg = 0;\nint tb = 0;\n\nvoid update(int timeDelta, long totalTime, long frameCount) {\n\n  // Fadeout\n  //boxRGBA(screen, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0,0,0, 10);\n  move(0, 1);\n  fade(35);\n\n  int second = getSecond();  \n  if (oldSecond != second) { \n    oldSecond = second;\n\n    int delta = 100;\n\n    tr += (rand() % delta) - delta/2; \n    tg += (rand() % delta) - delta/2; \n    tb += (rand() % delta) - delta/2; \n\n    tr = clampZeroTo255(tr);\n    tg = clampZeroTo255(tg);\n    tb = clampZeroTo255(tb);\n  }\n\n  int x = 2;\n  int y = 1;\n  writeTime(x, y, tr, tg, tb, 255);\n}\n\n\n\n// ----------\n\nint main( int argc, char* args[] ) { \n\n  long totalTime = 0;\n  long frameCount = 0;\n\n  // Initialize\n  if (!init()) return 1;\n\n  load_files();\n\n  // Clear existing pixels to transparent\n  clearDisplay(0,0,0,0);\n\n  // Loop  \n  bool quit = false;\n  while( quit == false ) {\n    \n    //Update Screen \n    SDL_Flip(screen); \n  \n    //Pause \n    usleep(SPEED * 1000);\n\n    // Check input\n    while (SDL_PollEvent(&event)) {\n\n      // Check for close button press \n      if (event.type == SDL_QUIT) { \n        quit = true; \n      } \n    }\n\n    // Update\n    totalTime += SPEED;\n    frameCount++;\n    update(SPEED, totalTime, frameCount);  \n\n    // Draw\n    drawDisplay();\n\n  }\n\n  clean_up();\n  return 0; \n}\n\n\n\n\n","Z:7uh>p2|d8-7ug*2|7+a*1|ed+8j8$/*\n\n\n*\n\n\n\n/*\nInformation radiator for raspberry PI.\n\nCompile with \ng++ -o piradiator piradiator.cpp -lSDL -lSDL_gfx\n\n*/\n\n#include \"SDL/SDL.h\" \n#include \"SDL/SDL_gfxPrimitives.h\" \n#include \x3cstring>\n#include \x3cstdlib.h>\n#include \x3ctime.h>\n#include \x3cctime>\n\n//Screen attributes \nconst int SCREEN_WIDTH = 800; \nconst int SCREEN_HEIGHT = 240; \nconst int SCREEN_BPP = 32; \n\nconst int SPEED = 100; \n\nSDL_Surface *screen = NULL;\n\nSDL_Event event;\n\nconst int DISPLAY_W = 48; \nconst int DISPLAY_H = 9; \n\nconst int DISPLAY_PIXEL_W = SCREEN_WIDTH / DISPLAY_W; \nconst int DISPLAY_PIXEL_H = SCREEN_HEIGHT / DISPLAY_H; \n\nconst int DISPLAY_SIZE = DISPLAY_W * DISPLAY_H;\nint display[DISPLAY_SIZE];\nint display2[DISPLAY_SIZE];\n\nconst int CHAR_W = 5; \nconst int CHAR_H = 7; \n\nint oldSecond = -1;\n\nint char0[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char1[] = {0, 0, 1, 0, 0,\n                 0, 1, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0 };\n\nint char2[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 1, 0, 0, 0,\n   1, 1, 1, 1, 1 }; \n\nint char3[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char4[] = \n  {1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1 }; \n\nint char5[] = \n  {1, 1, 1, 1, 1,\n   1, 0, 0, 0, 0,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char6[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char7[] = \n  {1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0 }; \n\nint char8[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char9[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint charColon[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nint charSpace[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nint charInvader1[] = \n  {1, 0, 0, 0, 1,\n   0, 1, 0, 1, 0,\n   1, 1, 1, 1, 1,\n   1, 0, 1, 0, 1,\n   1, 1, 1, 1, 1,\n   1, 0, 0, 0, 1,\n   1, 1, 0, 1, 1 }; \n\nbool init() { \n  // Init SDL\n  if (SDL_Init(SDL_INIT_EVERYTHING) == -1) { \n    return false; \n  } \n\n  // Set up the screen \n  screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, SDL_SWSURFACE); \n\n  // If there was an error in setting up the screen \n  if (screen == NULL) { return false; } \n\n  // Set the window caption \n  SDL_WM_SetCaption(\"PiRadiator\", NULL); \n\n  // Init display\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display[i] = 0;\n  } \n\n  // Init random\n  srand(time(NULL)); \n\n  // If everything initialized fine \n  return true; \n}\n\nvoid load_files() {\n}\n\nvoid clean_up() { \n   SDL_Quit(); \n}\n\n\nint clampZeroTo255(int v) {\n  if (v \x3c 0) return 0;\n  else if (v > 255) return 255;\n  else return v;\n}\n\nint colorRgb(int r, int g, int b) {\n  return SDL_MapRGB(screen->format, r, g, b);\n}\n\nint colorRgba(int r, int g, int b, int a) {\n  return SDL_MapRGBA(screen->format, r, g, b, a);\n}\n\nvoid fillRect(int x, int y, int w, int h, int color) {\n  SDL_Rect rect = {x,y,w,h};\n  SDL_FillRect(screen, &rect, color);\n}\n\n\nvoid drawDisplayPixel(int x, int y, int color) {  \n\n  int r = (color >> 24) & 0xFF;\n  int g = (color >> 16) & 0xFF;\n  int b = (color >> 8) & 0xFF;\n  int a = (color >> 0) & 0xFF;\n\n  int x1 = x * DISPLAY_PIXEL_W;\n  int y1 = y * DISPLAY_PIXEL_H;\n  int x2 = x1 + DISPLAY_PIXEL_W;\n  int y2 = y1 + DISPLAY_PIXEL_H;\n\n  int w = DISPLAY_PIXEL_W / 2;\n  int h = DISPLAY_PIXEL_H / 2;\n\n\n  int lum1 = 50;\n  int lum2 = 80;\n  int lum3 = 100;\n\n  int border1 = 1;\n  int border2 = 2;\n  int border3 = 4;\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border1, h-border1, r*lum1/100, g*lum1/100, b*lum1/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border2, h-border2, r*lum2/100, g*lum2/100, b*lum2/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border3, h-border3, r*lum3/100, g*lum3/100, b*lum3/100, 255);\n}\n\nint makeDisplayColor(int r, int g, int b, int a) {\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n\n    return (r \x3c\x3c 24) | (g \x3c\x3c 16) | (b \x3c\x3c 8) | (a);\n}\n\nvoid setPixel(int x, int y, int r, int g, int b, int a) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = makeDisplayColor(r, g, b, a);\n  }   \n}\n\nvoid setPixelColor(int x, int y, int color) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = color;\n  }   \n}\n\nvoid clearDisplay(int r, int g, int b, int a) {\n  int color = makeDisplayColor(r, g, b, a);\n\n  for (int i = 0; i \x3c DISPLAY_W * DISPLAY_H; i++) {\n    display[i] = color;\n  }\n}\n\nint getSecond() {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  return ltm->tm_sec;\n}\n\n\nvoid clearScreen(int color) {\n  SDL_FillRect(screen, NULL, color);\n}\n\n\nvoid drawDisplay() {\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      int col = display[y * DISPLAY_W + x];\n      if (col != 0) {\n        drawDisplayPixel(x, y, col);\n      }\n    }\n  }\n}\n\nvoid writeSprite(int xp, int yp, int *pic, int w, int h, int r, int g, int b, int a) {\n\n  int col = makeDisplayColor(r, g, b, a);\n\n  for (int y = yp; y \x3c yp + h; y++) {\n    for (int x = xp; x \x3c xp + w; x++) {\n      int idx = (y - yp) * w + (x - xp);\n      if (pic[idx] > 0) setPixelColor(x, y, col);\n    }\n  } \n}\n\nvoid writeChar(int x, int y, int r, int g, int b, int a, char c, bool invaders) {\n  int col = makeDisplayColor(r, g, b, a);\n\n  if (invaders && getSecond() == x / 5) {\n    c = '*';\n  }\n\n\n  switch (c) {\n    case '0': writeSprite(x, y, char0, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '1': writeSprite(x, y, char1, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '2': writeSprite(x, y, char2, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '3': writeSprite(x, y, char3, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '4': writeSprite(x, y, char4, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '5': writeSprite(x, y, char5, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '6': writeSprite(x, y, char6, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '7': writeSprite(x, y, char7, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '8': writeSprite(x, y, char8, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '9': writeSprite(x, y, char9, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ':': writeSprite(x, y, charColon, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ' ': writeSprite(x, y, charSpace, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '*': writeSprite(x, y, charInvader1, CHAR_W, CHAR_H, r, g, b, a); break;\n    default: ;\n  }\n}\n\nvoid writeNumber(int x, int y, int r, int g, int b, int a, int num, int digits, int spacing, bool invaders) {\n  bool numEncountered = false; \n  int xPos = x;\n  for (int digit = digits - 1; digit >= 0; digit--) {\n    int divider = 1;\n    for (int i = 0; i \x3c digit; i++) {\n      divider *= 10;\n    }\n\n    int d = (num / divider) % 10;         \n    numEncountered = numEncountered || (d != 0);\n\n    char ch = '0' + d;\n\n \n\n    /* Uncomment to skip leading zeroes\n    if (numEncountered || digit == 0) {\n    */\n      writeChar(xPos, y, r, g, b, a, ch, invaders);\n    /*\n    }\n    */\n \n    xPos += CHAR_W + spacing;\n  }\n}\n\n\n// ---------\n\nvoid move(int dx, int dy) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display2[i] = display[i];\n  }\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      setPixelColor(x + dx, y + dy, display2[y * DISPLAY_W + x]);\n    }\n  }\n}\n\nvoid fade(int fadeAmount) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    int color = display[i];\n    int r =  (color >> 24) & 0xFF;\n    int g =  (color >> 16) & 0xFF;\n    int b =  (color >> 8) & 0xFF;\n    int a =  (color >> 0) & 0xFF;\n    r = r * fadeAmount / 100;    \n    g = g * fadeAmount / 100;    \n    b = b * fadeAmount / 100;\n    a = 255;\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n    display[i] = ((r & 0xFF) \x3c\x3c 24) | ((g & 0xFF) \x3c\x3c 16) | ((b & 0xFF) \x3c\x3c 8) | ((a & 0xFF) \x3c\x3c 0);   \n  }    \n}\n\nbool invaders = false;\n\nvoid writeTime(int x, int y, int r, int g, int b, int a) {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  \n  // Check if we got invaded\n  if ((rand() % 100) \x3c= 1) {\n    invaders = true;\n  }\n  if ((rand() % 100) \x3c= 20) {\n    invaders = false;\n  }\n  if (ltm->tm_hour > 3 && ltm->tm_hour \x3c 7 && (rand() % 100) \x3c 20) {\n    invaders = true;\n  }\n\n  int spacing = 2;\n  int numW = CHAR_W * 2 + spacing;\n  int xPos = x;\n  int digits = 2;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_hour, digits, spacing, invaders);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':', false);\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_min, digits, spacing, invaders);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':', false);\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_sec, digits, spacing, invaders);\n}\n\nint tr = 255;\nint tg = 0;\nint tb = 0;\n\nvoid update(int timeDelta, long totalTime, long frameCount) {\n\n  // Fadeout\n  //boxRGBA(screen, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0,0,0, 10);\n  move(0, 1);\n  fade(35);\n\n  int second = getSecond();  \n  if (oldSecond != second) { \n    oldSecond = second;\n  \n    // Change color\n    int delta = 100;\n    \n    tr += (rand() % delta) - delta/2; \n    tg += (rand() % delta) - delta/2; \n    tb += (rand() % delta) - delta/2; \n\n    tr = clampZeroTo255(tr);\n    tg = clampZeroTo255(tg);\n    tb = clampZeroTo255(tb);\n\n    // Avoid going too dark \n    if (tr + tg + tb \x3c 150) {\n      if ((rand() % 100) \x3c 30) tr = 255;\n      else if ((rand() % 100) \x3c 50) tg = 255;\n      else tb = 255;\n    }\n  }\n\n  int x = 2;\n  int y = 1;\n  writeTime(x, y, tr, tg, tb, 255);\n}\n\n\n\n// ----------\n\nint main( int argc, char* args[] ) { \n\n  long totalTime = 0;\n  long frameCount = 0;\n\n  // Initialize\n  if (!init()) return 1;\n\n  load_files();\n\n  // Clear existing pixels to transparent\n  clearDisplay(0,0,0,0);\n\n  // Loop  \n  bool quit = false;\n  while( quit == false ) {\n    \n    //Update Screen \n    SDL_Flip(screen); \n  \n    //Pause \n    usleep(SPEED * 1000);\n\n    // Check input\n    while (SDL_PollEvent(&event)) {\n\n      // Check for close button press \n      if (event.type == SDL_QUIT) { \n        quit = true; \n      } \n    }\n\n    // Update\n    totalTime += SPEED;\n    frameCount++;\n    update(SPEED, totalTime, frameCount);  \n\n    // Draw\n    drawDisplay();\n\n  }\n\n  clean_up();\n  return 0; \n}\n\n\n\n","Z:8jj>e|1=3*2+d|2=2=1*2+1$    For Open /","Z:8jx>6|1=3=c-1*2+7$GL ES 2","Z:8k3>k|1=3=j*2|1+g*2+4$.0 programming:\n    "],"timeDeltas":[17,27,15,15332,143539,13873,6,6,7],"granularity":10,"actualEndNum":90,"apool":{"numToAttrib":{"0":["author","g.7adqe1th72vgygl8"],"1":["author","g.fgbk65v1gwktdgo5"],"2":["author","g.s2bud5tbeqc1y5gb"]},"nextNum":3},"backwardsChangesets":["Z:1c\x3c1b|3-1a-1$","Z:bh\x3ca5|3=1a=1|p-a5$","Z:bk\x3c3|1-3$","Z:1>bj*0|2+h*0+u|1+1*0|3+l|1+1*0|l+9j*0+1|1+1$/*\nCompile with \ng++ -o pidemo pidemo.cpp -lSDL\n\nCode (pidemo.cpp):\n\n\n#include \"SDL/SDL.h\" \n\nint main( int argc, char* args[] ) { \n  SDL_Surface* screen = NULL;\n\n  //Start SDL \n  SDL_Init( SDL_INIT_EVERYTHING ); \n\n //Set up screen\n  screen = SDL_SetVideoMode( 1024, 320, 32, SDL_SWSURFACE ); \n\n  //Update Screen \n  SDL_Flip(screen); \n  \n  //Pause \n  SDL_Delay(2000);\n\n  //Quit SDL \n  SDL_Quit(); \n  \n  return 0; \n}\n","Z:7uh\x3c7ug|d8-7ug$","Z:8jj\x3cp2|ek-8ji*1|d8+7ug$/*\nInformation radiator for raspberry PI.\n\nCompile with \ng++ -o piradiator piradiator.cpp -lSDL -lSDL_gfx\n\n*/\n\n#include \"SDL/SDL.h\" \n#include \"SDL/SDL_gfxPrimitives.h\" \n#include \x3cstring>\n#include \x3cstdlib.h>\n#include \x3ctime.h>\n#include \x3cctime>\n\n//Screen attributes \nconst int SCREEN_WIDTH = 800; \nconst int SCREEN_HEIGHT = 240; \nconst int SCREEN_BPP = 32; \n\nconst int SPEED = 100; \n\nSDL_Surface *screen = NULL;\n\nSDL_Event event;\n\nconst int DISPLAY_W = 48; \nconst int DISPLAY_H = 9; \n\nconst int DISPLAY_PIXEL_W = SCREEN_WIDTH / DISPLAY_W; \nconst int DISPLAY_PIXEL_H = SCREEN_HEIGHT / DISPLAY_H; \n\nconst int DISPLAY_SIZE = DISPLAY_W * DISPLAY_H;\nint display[DISPLAY_SIZE];\nint display2[DISPLAY_SIZE];\n\nconst int CHAR_W = 5; \nconst int CHAR_H = 7; \n\nint oldSecond = -1;\n\nint char0[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char1[] = {0, 0, 1, 0, 0,\n                 0, 1, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0 };\n\nint char2[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 1, 0, 0, 0,\n   1, 1, 1, 1, 1 }; \n\nint char3[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char4[] = \n  {1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1 }; \n\nint char5[] = \n  {1, 1, 1, 1, 1,\n   1, 0, 0, 0, 0,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char6[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char7[] = \n  {1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0 }; \n\nint char8[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char9[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint charColon[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nint charSpace[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nbool init() { \n  // Init SDL\n  if (SDL_Init(SDL_INIT_EVERYTHING) == -1) { \n    return false; \n  } \n\n  // Set up the screen \n  screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, SDL_SWSURFACE); \n\n  // If there was an error in setting up the screen \n  if (screen == NULL) { return false; } \n\n  // Set the window caption \n  SDL_WM_SetCaption(\"PiRadiator\", NULL); \n\n  // Init display\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display[i] = 0;\n  } \n\n  // Init random\n  srand(time(NULL)); \n\n  // If everything initialized fine \n  return true; \n}\n\nvoid load_files() {\n}\n\nvoid clean_up() { \n   SDL_Quit(); \n}\n\n\nint clampZeroTo255(int v) {\n  if (v \x3c 0) return 0;\n  else if (v > 255) return 255;\n  else return v;\n}\n\nint colorRgb(int r, int g, int b) {\n  return SDL_MapRGB(screen->format, r, g, b);\n}\n\nint colorRgba(int r, int g, int b, int a) {\n  return SDL_MapRGBA(screen->format, r, g, b, a);\n}\n\nvoid fillRect(int x, int y, int w, int h, int color) {\n  SDL_Rect rect = {x,y,w,h};\n  SDL_FillRect(screen, &rect, color);\n}\n\n\nvoid drawDisplayPixel(int x, int y, int color) {  \n\n  int r = (color >> 24) & 0xFF;\n  int g = (color >> 16) & 0xFF;\n  int b = (color >> 8) & 0xFF;\n  int a = (color >> 0) & 0xFF;\n\n  int x1 = x * DISPLAY_PIXEL_W;\n  int y1 = y * DISPLAY_PIXEL_H;\n  int x2 = x1 + DISPLAY_PIXEL_W;\n  int y2 = y1 + DISPLAY_PIXEL_H;\n\n  int w = DISPLAY_PIXEL_W / 2;\n  int h = DISPLAY_PIXEL_H / 2;\n\n\n  int lum1 = 50;\n  int lum2 = 80;\n  int lum3 = 100;\n\n  int border1 = 1;\n  int border2 = 2;\n  int border3 = 4;\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border1, h-border1, r*lum1/100, g*lum1/100, b*lum1/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border2, h-border2, r*lum2/100, g*lum2/100, b*lum2/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border3, h-border3, r*lum3/100, g*lum3/100, b*lum3/100, 255);\n}\n\nint makeDisplayColor(int r, int g, int b, int a) {\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n\n    return (r \x3c\x3c 24) | (g \x3c\x3c 16) | (b \x3c\x3c 8) | (a);\n}\n\nvoid setPixel(int x, int y, int r, int g, int b, int a) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = makeDisplayColor(r, g, b, a);\n  }   \n}\n\nvoid setPixelColor(int x, int y, int color) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = color;\n  }   \n}\n\nvoid clearDisplay(int r, int g, int b, int a) {\n  int color = makeDisplayColor(r, g, b, a);\n\n  for (int i = 0; i \x3c DISPLAY_W * DISPLAY_H; i++) {\n    display[i] = color;\n  }\n}\n\nvoid clearScreen(int color) {\n  SDL_FillRect(screen, NULL, color);\n}\n\n\nvoid drawDisplay() {\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      int col = display[y * DISPLAY_W + x];\n      if (col != 0) {\n        drawDisplayPixel(x, y, col);\n      }\n    }\n  }\n}\n\nvoid writeSprite(int xp, int yp, int *pic, int w, int h, int r, int g, int b, int a) {\n\n  int col = makeDisplayColor(r, g, b, a);\n\n  for (int y = yp; y \x3c yp + h; y++) {\n    for (int x = xp; x \x3c xp + w; x++) {\n      int idx = (y - yp) * w + (x - xp);\n      if (pic[idx] > 0) setPixelColor(x, y, col);\n    }\n  } \n}\n\nvoid writeChar(int x, int y, int r, int g, int b, int a, char c) {\n  int col = makeDisplayColor(r, g, b, a);\n\n  switch (c) {\n    case '0': writeSprite(x, y, char0, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '1': writeSprite(x, y, char1, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '2': writeSprite(x, y, char2, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '3': writeSprite(x, y, char3, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '4': writeSprite(x, y, char4, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '5': writeSprite(x, y, char5, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '6': writeSprite(x, y, char6, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '7': writeSprite(x, y, char7, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '8': writeSprite(x, y, char8, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '9': writeSprite(x, y, char9, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ':': writeSprite(x, y, charColon, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ' ': writeSprite(x, y, charSpace, CHAR_W, CHAR_H, r, g, b, a); break;\n    default: ;\n  }\n}\n\nvoid writeNumber(int x, int y, int r, int g, int b, int a, int num, int digits, int spacing) {\n  bool numEncountered = false; \n  int xPos = x;\n  for (int digit = digits - 1; digit >= 0; digit--) {\n    int divider = 1;\n    for (int i = 0; i \x3c digit; i++) {\n      divider *= 10;\n    }\n\n    int d = (num / divider) % 10;         \n    numEncountered = numEncountered || (d != 0);\n\n    /* Uncomment to skip leading zeroes\n    if (numEncountered || digit == 0) {\n    */\n      writeChar(xPos, y, r, g, b, a, '0' + d);\n    /*\n    }\n    */\n \n    xPos += CHAR_W + spacing;\n  }\n}\n\n\n// ---------\n\nvoid move(int dx, int dy) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display2[i] = display[i];\n  }\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      setPixelColor(x + dx, y + dy, display2[y * DISPLAY_W + x]);\n    }\n  }\n}\n\nvoid fade(int fadeAmount) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    int color = display[i];\n    int r =  (color >> 24) & 0xFF;\n    int g =  (color >> 16) & 0xFF;\n    int b =  (color >> 8) & 0xFF;\n    int a =  (color >> 0) & 0xFF;\n    r = r * fadeAmount / 100;    \n    g = g * fadeAmount / 100;    \n    b = b * fadeAmount / 100;\n    a = 255;\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n    display[i] = ((r & 0xFF) \x3c\x3c 24) | ((g & 0xFF) \x3c\x3c 16) | ((b & 0xFF) \x3c\x3c 8) | ((a & 0xFF) \x3c\x3c 0);   \n  }    \n}\n\nint getSecond() {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  return ltm->tm_sec;\n}\n\nvoid writeTime(int x, int y, int r, int g, int b, int a) {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  \n  int spacing = 2;\n  int numW = CHAR_W * 2 + spacing;\n  int xPos = x;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_hour, 2, spacing);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':');\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_min, 2, spacing);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':');\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_sec, 2, spacing);\n}\n\nint tr = 255;\nint tg = 0;\nint tb = 0;\n\nvoid update(int timeDelta, long totalTime, long frameCount) {\n\n  // Fadeout\n  //boxRGBA(screen, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0,0,0, 10);\n  move(0, 1);\n  fade(35);\n\n  int second = getSecond();  \n  if (oldSecond != second) { \n    oldSecond = second;\n\n    int delta = 100;\n\n    tr += (rand() % delta) - delta/2; \n    tg += (rand() % delta) - delta/2; \n    tb += (rand() % delta) - delta/2; \n\n    tr = clampZeroTo255(tr);\n    tg = clampZeroTo255(tg);\n    tb = clampZeroTo255(tb);\n  }\n\n  int x = 2;\n  int y = 1;\n  writeTime(x, y, tr, tg, tb, 255);\n}\n\n\n\n// ----------\n\nint main( int argc, char* args[] ) { \n\n  long totalTime = 0;\n  long frameCount = 0;\n\n  // Initialize\n  if (!init()) return 1;\n\n  load_files();\n\n  // Clear existing pixels to transparent\n  clearDisplay(0,0,0,0);\n\n  // Loop  \n  bool quit = false;\n  while( quit == false ) {\n    \n    //Update Screen \n    SDL_Flip(screen); \n  \n    //Pause \n    usleep(SPEED * 1000);\n\n    // Check input\n    while (SDL_PollEvent(&event)) {\n\n      // Check for close button press \n      if (event.type == SDL_QUIT) { \n        quit = true; \n      } \n    }\n\n    // Update\n    totalTime += SPEED;\n    frameCount++;\n    update(SPEED, totalTime, frameCount);  \n\n    // Draw\n    drawDisplay();\n\n  }\n\n  clean_up();\n  return 0; \n}\n\n\n\n\n","Z:8jx\x3ce|1=3-d|2=2=1-1$","Z:8k3\x3c6|1=3=c-7*2+1$ ","Z:8kn\x3ck|1=3=j|1-g-4$"]},{"start":90,"forwardsChangesets":["Z:8kn>2s|2=12=4*0+2s$http://benosteen.wordpress.com/2012/04/27/using-opengl-es-2-0-on-the-raspberry-pi-without-x-windows/","Z:8nf>1|2=12*0*1*2+1$*","Z:8ng\x3c1|3=40|1-1$","Z:8nf>0*3|4=43$"],"timeDeltas":[1,5,6,8],"granularity":1,"actualEndNum":94,"apool":{"numToAttrib":{"0":["author","g.s2bud5tbeqc1y5gb"],"1":["insertorder","first"],"2":["list","bullet1"],"3":["author",""]},"nextNum":4},"backwardsChangesets":["Z:8nf\x3c2s|2=12=4-2s$","Z:8ng\x3c1|2=12-1$","Z:8nf>1|3=40*0|1+1$\n","Z:8nf>0*0|4=43$"]},{"start":0,"forwardsChangesets":["Z:1>1b*0|1+e*0+u|1+1*0|1+1*0+1$Compile with \ng++ -o pidemo pidemo.cpp -lSDL\n\nC","Z:1c>a5|3=1a=1*0|2+j|1+1*0|l+9j*0+1|1+1$ode (pidemo.cpp):\n\n\n#include \"SDL/SDL.h\" \n\nint main( int argc, char* args[] ) { \n  SDL_Surface* screen = NULL;\n\n  //Start SDL \n  SDL_Init( SDL_INIT_EVERYTHING ); \n\n //Set up screen\n  screen = SDL_SetVideoMode( 1024, 320, 32, SDL_SWSURFACE ); \n\n  //Update Screen \n  SDL_Flip(screen); \n  \n  //Pause \n  SDL_Delay(2000);\n\n  //Quit SDL \n  SDL_Quit(); \n  \n  return 0; \n}\n","Z:bh>3*0|1+3$/*\n","Z:bk\x3cbj|t-bj$","Z:1>7ug*1|d8+7ug$/*\nInformation radiator for raspberry PI.\n\nCompile with \ng++ -o piradiator piradiator.cpp -lSDL -lSDL_gfx\n\n*/\n\n#include \"SDL/SDL.h\" \n#include \"SDL/SDL_gfxPrimitives.h\" \n#include \x3cstring>\n#include \x3cstdlib.h>\n#include \x3ctime.h>\n#include \x3cctime>\n\n//Screen attributes \nconst int SCREEN_WIDTH = 800; \nconst int SCREEN_HEIGHT = 240; \nconst int SCREEN_BPP = 32; \n\nconst int SPEED = 100; \n\nSDL_Surface *screen = NULL;\n\nSDL_Event event;\n\nconst int DISPLAY_W = 48; \nconst int DISPLAY_H = 9; \n\nconst int DISPLAY_PIXEL_W = SCREEN_WIDTH / DISPLAY_W; \nconst int DISPLAY_PIXEL_H = SCREEN_HEIGHT / DISPLAY_H; \n\nconst int DISPLAY_SIZE = DISPLAY_W * DISPLAY_H;\nint display[DISPLAY_SIZE];\nint display2[DISPLAY_SIZE];\n\nconst int CHAR_W = 5; \nconst int CHAR_H = 7; \n\nint oldSecond = -1;\n\nint char0[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char1[] = {0, 0, 1, 0, 0,\n                 0, 1, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0 };\n\nint char2[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 1, 0, 0, 0,\n   1, 1, 1, 1, 1 }; \n\nint char3[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char4[] = \n  {1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1 }; \n\nint char5[] = \n  {1, 1, 1, 1, 1,\n   1, 0, 0, 0, 0,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char6[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char7[] = \n  {1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0 }; \n\nint char8[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char9[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint charColon[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nint charSpace[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nbool init() { \n  // Init SDL\n  if (SDL_Init(SDL_INIT_EVERYTHING) == -1) { \n    return false; \n  } \n\n  // Set up the screen \n  screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, SDL_SWSURFACE); \n\n  // If there was an error in setting up the screen \n  if (screen == NULL) { return false; } \n\n  // Set the window caption \n  SDL_WM_SetCaption(\"PiRadiator\", NULL); \n\n  // Init display\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display[i] = 0;\n  } \n\n  // Init random\n  srand(time(NULL)); \n\n  // If everything initialized fine \n  return true; \n}\n\nvoid load_files() {\n}\n\nvoid clean_up() { \n   SDL_Quit(); \n}\n\n\nint clampZeroTo255(int v) {\n  if (v \x3c 0) return 0;\n  else if (v > 255) return 255;\n  else return v;\n}\n\nint colorRgb(int r, int g, int b) {\n  return SDL_MapRGB(screen->format, r, g, b);\n}\n\nint colorRgba(int r, int g, int b, int a) {\n  return SDL_MapRGBA(screen->format, r, g, b, a);\n}\n\nvoid fillRect(int x, int y, int w, int h, int color) {\n  SDL_Rect rect = {x,y,w,h};\n  SDL_FillRect(screen, &rect, color);\n}\n\n\nvoid drawDisplayPixel(int x, int y, int color) {  \n\n  int r = (color >> 24) & 0xFF;\n  int g = (color >> 16) & 0xFF;\n  int b = (color >> 8) & 0xFF;\n  int a = (color >> 0) & 0xFF;\n\n  int x1 = x * DISPLAY_PIXEL_W;\n  int y1 = y * DISPLAY_PIXEL_H;\n  int x2 = x1 + DISPLAY_PIXEL_W;\n  int y2 = y1 + DISPLAY_PIXEL_H;\n\n  int w = DISPLAY_PIXEL_W / 2;\n  int h = DISPLAY_PIXEL_H / 2;\n\n\n  int lum1 = 50;\n  int lum2 = 80;\n  int lum3 = 100;\n\n  int border1 = 1;\n  int border2 = 2;\n  int border3 = 4;\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border1, h-border1, r*lum1/100, g*lum1/100, b*lum1/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border2, h-border2, r*lum2/100, g*lum2/100, b*lum2/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border3, h-border3, r*lum3/100, g*lum3/100, b*lum3/100, 255);\n}\n\nint makeDisplayColor(int r, int g, int b, int a) {\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n\n    return (r \x3c\x3c 24) | (g \x3c\x3c 16) | (b \x3c\x3c 8) | (a);\n}\n\nvoid setPixel(int x, int y, int r, int g, int b, int a) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = makeDisplayColor(r, g, b, a);\n  }   \n}\n\nvoid setPixelColor(int x, int y, int color) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = color;\n  }   \n}\n\nvoid clearDisplay(int r, int g, int b, int a) {\n  int color = makeDisplayColor(r, g, b, a);\n\n  for (int i = 0; i \x3c DISPLAY_W * DISPLAY_H; i++) {\n    display[i] = color;\n  }\n}\n\nvoid clearScreen(int color) {\n  SDL_FillRect(screen, NULL, color);\n}\n\n\nvoid drawDisplay() {\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      int col = display[y * DISPLAY_W + x];\n      if (col != 0) {\n        drawDisplayPixel(x, y, col);\n      }\n    }\n  }\n}\n\nvoid writeSprite(int xp, int yp, int *pic, int w, int h, int r, int g, int b, int a) {\n\n  int col = makeDisplayColor(r, g, b, a);\n\n  for (int y = yp; y \x3c yp + h; y++) {\n    for (int x = xp; x \x3c xp + w; x++) {\n      int idx = (y - yp) * w + (x - xp);\n      if (pic[idx] > 0) setPixelColor(x, y, col);\n    }\n  } \n}\n\nvoid writeChar(int x, int y, int r, int g, int b, int a, char c) {\n  int col = makeDisplayColor(r, g, b, a);\n\n  switch (c) {\n    case '0': writeSprite(x, y, char0, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '1': writeSprite(x, y, char1, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '2': writeSprite(x, y, char2, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '3': writeSprite(x, y, char3, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '4': writeSprite(x, y, char4, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '5': writeSprite(x, y, char5, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '6': writeSprite(x, y, char6, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '7': writeSprite(x, y, char7, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '8': writeSprite(x, y, char8, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '9': writeSprite(x, y, char9, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ':': writeSprite(x, y, charColon, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ' ': writeSprite(x, y, charSpace, CHAR_W, CHAR_H, r, g, b, a); break;\n    default: ;\n  }\n}\n\nvoid writeNumber(int x, int y, int r, int g, int b, int a, int num, int digits, int spacing) {\n  bool numEncountered = false; \n  int xPos = x;\n  for (int digit = digits - 1; digit >= 0; digit--) {\n    int divider = 1;\n    for (int i = 0; i \x3c digit; i++) {\n      divider *= 10;\n    }\n\n    int d = (num / divider) % 10;         \n    numEncountered = numEncountered || (d != 0);\n\n    /* Uncomment to skip leading zeroes\n    if (numEncountered || digit == 0) {\n    */\n      writeChar(xPos, y, r, g, b, a, '0' + d);\n    /*\n    }\n    */\n \n    xPos += CHAR_W + spacing;\n  }\n}\n\n\n// ---------\n\nvoid move(int dx, int dy) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display2[i] = display[i];\n  }\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      setPixelColor(x + dx, y + dy, display2[y * DISPLAY_W + x]);\n    }\n  }\n}\n\nvoid fade(int fadeAmount) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    int color = display[i];\n    int r =  (color >> 24) & 0xFF;\n    int g =  (color >> 16) & 0xFF;\n    int b =  (color >> 8) & 0xFF;\n    int a =  (color >> 0) & 0xFF;\n    r = r * fadeAmount / 100;    \n    g = g * fadeAmount / 100;    \n    b = b * fadeAmount / 100;\n    a = 255;\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n    display[i] = ((r & 0xFF) \x3c\x3c 24) | ((g & 0xFF) \x3c\x3c 16) | ((b & 0xFF) \x3c\x3c 8) | ((a & 0xFF) \x3c\x3c 0);   \n  }    \n}\n\nint getSecond() {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  return ltm->tm_sec;\n}\n\nvoid writeTime(int x, int y, int r, int g, int b, int a) {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  \n  int spacing = 2;\n  int numW = CHAR_W * 2 + spacing;\n  int xPos = x;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_hour, 2, spacing);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':');\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_min, 2, spacing);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':');\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_sec, 2, spacing);\n}\n\nint tr = 255;\nint tg = 0;\nint tb = 0;\n\nvoid update(int timeDelta, long totalTime, long frameCount) {\n\n  // Fadeout\n  //boxRGBA(screen, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0,0,0, 10);\n  move(0, 1);\n  fade(35);\n\n  int second = getSecond();  \n  if (oldSecond != second) { \n    oldSecond = second;\n\n    int delta = 100;\n\n    tr += (rand() % delta) - delta/2; \n    tg += (rand() % delta) - delta/2; \n    tb += (rand() % delta) - delta/2; \n\n    tr = clampZeroTo255(tr);\n    tg = clampZeroTo255(tg);\n    tb = clampZeroTo255(tb);\n  }\n\n  int x = 2;\n  int y = 1;\n  writeTime(x, y, tr, tg, tb, 255);\n}\n\n\n\n// ----------\n\nint main( int argc, char* args[] ) { \n\n  long totalTime = 0;\n  long frameCount = 0;\n\n  // Initialize\n  if (!init()) return 1;\n\n  load_files();\n\n  // Clear existing pixels to transparent\n  clearDisplay(0,0,0,0);\n\n  // Loop  \n  bool quit = false;\n  while( quit == false ) {\n    \n    //Update Screen \n    SDL_Flip(screen); \n  \n    //Pause \n    usleep(SPEED * 1000);\n\n    // Check input\n    while (SDL_PollEvent(&event)) {\n\n      // Check for close button press \n      if (event.type == SDL_QUIT) { \n        quit = true; \n      } \n    }\n\n    // Update\n    totalTime += SPEED;\n    frameCount++;\n    update(SPEED, totalTime, frameCount);  \n\n    // Draw\n    drawDisplay();\n\n  }\n\n  clean_up();\n  return 0; \n}\n\n\n\n\n","Z:7uh>p2|d8-7ug*2|7+a*1|ed+8j8$/*\n\n\n*\n\n\n\n/*\nInformation radiator for raspberry PI.\n\nCompile with \ng++ -o piradiator piradiator.cpp -lSDL -lSDL_gfx\n\n*/\n\n#include \"SDL/SDL.h\" \n#include \"SDL/SDL_gfxPrimitives.h\" \n#include \x3cstring>\n#include \x3cstdlib.h>\n#include \x3ctime.h>\n#include \x3cctime>\n\n//Screen attributes \nconst int SCREEN_WIDTH = 800; \nconst int SCREEN_HEIGHT = 240; \nconst int SCREEN_BPP = 32; \n\nconst int SPEED = 100; \n\nSDL_Surface *screen = NULL;\n\nSDL_Event event;\n\nconst int DISPLAY_W = 48; \nconst int DISPLAY_H = 9; \n\nconst int DISPLAY_PIXEL_W = SCREEN_WIDTH / DISPLAY_W; \nconst int DISPLAY_PIXEL_H = SCREEN_HEIGHT / DISPLAY_H; \n\nconst int DISPLAY_SIZE = DISPLAY_W * DISPLAY_H;\nint display[DISPLAY_SIZE];\nint display2[DISPLAY_SIZE];\n\nconst int CHAR_W = 5; \nconst int CHAR_H = 7; \n\nint oldSecond = -1;\n\nint char0[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char1[] = {0, 0, 1, 0, 0,\n                 0, 1, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0 };\n\nint char2[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 1, 0, 0, 0,\n   1, 1, 1, 1, 1 }; \n\nint char3[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char4[] = \n  {1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1 }; \n\nint char5[] = \n  {1, 1, 1, 1, 1,\n   1, 0, 0, 0, 0,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char6[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char7[] = \n  {1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0 }; \n\nint char8[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char9[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint charColon[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nint charSpace[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nint charInvader1[] = \n  {1, 0, 0, 0, 1,\n   0, 1, 0, 1, 0,\n   1, 1, 1, 1, 1,\n   1, 0, 1, 0, 1,\n   1, 1, 1, 1, 1,\n   1, 0, 0, 0, 1,\n   1, 1, 0, 1, 1 }; \n\nbool init() { \n  // Init SDL\n  if (SDL_Init(SDL_INIT_EVERYTHING) == -1) { \n    return false; \n  } \n\n  // Set up the screen \n  screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, SDL_SWSURFACE); \n\n  // If there was an error in setting up the screen \n  if (screen == NULL) { return false; } \n\n  // Set the window caption \n  SDL_WM_SetCaption(\"PiRadiator\", NULL); \n\n  // Init display\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display[i] = 0;\n  } \n\n  // Init random\n  srand(time(NULL)); \n\n  // If everything initialized fine \n  return true; \n}\n\nvoid load_files() {\n}\n\nvoid clean_up() { \n   SDL_Quit(); \n}\n\n\nint clampZeroTo255(int v) {\n  if (v \x3c 0) return 0;\n  else if (v > 255) return 255;\n  else return v;\n}\n\nint colorRgb(int r, int g, int b) {\n  return SDL_MapRGB(screen->format, r, g, b);\n}\n\nint colorRgba(int r, int g, int b, int a) {\n  return SDL_MapRGBA(screen->format, r, g, b, a);\n}\n\nvoid fillRect(int x, int y, int w, int h, int color) {\n  SDL_Rect rect = {x,y,w,h};\n  SDL_FillRect(screen, &rect, color);\n}\n\n\nvoid drawDisplayPixel(int x, int y, int color) {  \n\n  int r = (color >> 24) & 0xFF;\n  int g = (color >> 16) & 0xFF;\n  int b = (color >> 8) & 0xFF;\n  int a = (color >> 0) & 0xFF;\n\n  int x1 = x * DISPLAY_PIXEL_W;\n  int y1 = y * DISPLAY_PIXEL_H;\n  int x2 = x1 + DISPLAY_PIXEL_W;\n  int y2 = y1 + DISPLAY_PIXEL_H;\n\n  int w = DISPLAY_PIXEL_W / 2;\n  int h = DISPLAY_PIXEL_H / 2;\n\n\n  int lum1 = 50;\n  int lum2 = 80;\n  int lum3 = 100;\n\n  int border1 = 1;\n  int border2 = 2;\n  int border3 = 4;\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border1, h-border1, r*lum1/100, g*lum1/100, b*lum1/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border2, h-border2, r*lum2/100, g*lum2/100, b*lum2/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border3, h-border3, r*lum3/100, g*lum3/100, b*lum3/100, 255);\n}\n\nint makeDisplayColor(int r, int g, int b, int a) {\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n\n    return (r \x3c\x3c 24) | (g \x3c\x3c 16) | (b \x3c\x3c 8) | (a);\n}\n\nvoid setPixel(int x, int y, int r, int g, int b, int a) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = makeDisplayColor(r, g, b, a);\n  }   \n}\n\nvoid setPixelColor(int x, int y, int color) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = color;\n  }   \n}\n\nvoid clearDisplay(int r, int g, int b, int a) {\n  int color = makeDisplayColor(r, g, b, a);\n\n  for (int i = 0; i \x3c DISPLAY_W * DISPLAY_H; i++) {\n    display[i] = color;\n  }\n}\n\nint getSecond() {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  return ltm->tm_sec;\n}\n\n\nvoid clearScreen(int color) {\n  SDL_FillRect(screen, NULL, color);\n}\n\n\nvoid drawDisplay() {\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      int col = display[y * DISPLAY_W + x];\n      if (col != 0) {\n        drawDisplayPixel(x, y, col);\n      }\n    }\n  }\n}\n\nvoid writeSprite(int xp, int yp, int *pic, int w, int h, int r, int g, int b, int a) {\n\n  int col = makeDisplayColor(r, g, b, a);\n\n  for (int y = yp; y \x3c yp + h; y++) {\n    for (int x = xp; x \x3c xp + w; x++) {\n      int idx = (y - yp) * w + (x - xp);\n      if (pic[idx] > 0) setPixelColor(x, y, col);\n    }\n  } \n}\n\nvoid writeChar(int x, int y, int r, int g, int b, int a, char c, bool invaders) {\n  int col = makeDisplayColor(r, g, b, a);\n\n  if (invaders && getSecond() == x / 5) {\n    c = '*';\n  }\n\n\n  switch (c) {\n    case '0': writeSprite(x, y, char0, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '1': writeSprite(x, y, char1, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '2': writeSprite(x, y, char2, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '3': writeSprite(x, y, char3, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '4': writeSprite(x, y, char4, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '5': writeSprite(x, y, char5, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '6': writeSprite(x, y, char6, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '7': writeSprite(x, y, char7, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '8': writeSprite(x, y, char8, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '9': writeSprite(x, y, char9, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ':': writeSprite(x, y, charColon, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ' ': writeSprite(x, y, charSpace, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '*': writeSprite(x, y, charInvader1, CHAR_W, CHAR_H, r, g, b, a); break;\n    default: ;\n  }\n}\n\nvoid writeNumber(int x, int y, int r, int g, int b, int a, int num, int digits, int spacing, bool invaders) {\n  bool numEncountered = false; \n  int xPos = x;\n  for (int digit = digits - 1; digit >= 0; digit--) {\n    int divider = 1;\n    for (int i = 0; i \x3c digit; i++) {\n      divider *= 10;\n    }\n\n    int d = (num / divider) % 10;         \n    numEncountered = numEncountered || (d != 0);\n\n    char ch = '0' + d;\n\n \n\n    /* Uncomment to skip leading zeroes\n    if (numEncountered || digit == 0) {\n    */\n      writeChar(xPos, y, r, g, b, a, ch, invaders);\n    /*\n    }\n    */\n \n    xPos += CHAR_W + spacing;\n  }\n}\n\n\n// ---------\n\nvoid move(int dx, int dy) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display2[i] = display[i];\n  }\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      setPixelColor(x + dx, y + dy, display2[y * DISPLAY_W + x]);\n    }\n  }\n}\n\nvoid fade(int fadeAmount) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    int color = display[i];\n    int r =  (color >> 24) & 0xFF;\n    int g =  (color >> 16) & 0xFF;\n    int b =  (color >> 8) & 0xFF;\n    int a =  (color >> 0) & 0xFF;\n    r = r * fadeAmount / 100;    \n    g = g * fadeAmount / 100;    \n    b = b * fadeAmount / 100;\n    a = 255;\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n    display[i] = ((r & 0xFF) \x3c\x3c 24) | ((g & 0xFF) \x3c\x3c 16) | ((b & 0xFF) \x3c\x3c 8) | ((a & 0xFF) \x3c\x3c 0);   \n  }    \n}\n\nbool invaders = false;\n\nvoid writeTime(int x, int y, int r, int g, int b, int a) {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  \n  // Check if we got invaded\n  if ((rand() % 100) \x3c= 1) {\n    invaders = true;\n  }\n  if ((rand() % 100) \x3c= 20) {\n    invaders = false;\n  }\n  if (ltm->tm_hour > 3 && ltm->tm_hour \x3c 7 && (rand() % 100) \x3c 20) {\n    invaders = true;\n  }\n\n  int spacing = 2;\n  int numW = CHAR_W * 2 + spacing;\n  int xPos = x;\n  int digits = 2;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_hour, digits, spacing, invaders);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':', false);\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_min, digits, spacing, invaders);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':', false);\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_sec, digits, spacing, invaders);\n}\n\nint tr = 255;\nint tg = 0;\nint tb = 0;\n\nvoid update(int timeDelta, long totalTime, long frameCount) {\n\n  // Fadeout\n  //boxRGBA(screen, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0,0,0, 10);\n  move(0, 1);\n  fade(35);\n\n  int second = getSecond();  \n  if (oldSecond != second) { \n    oldSecond = second;\n  \n    // Change color\n    int delta = 100;\n    \n    tr += (rand() % delta) - delta/2; \n    tg += (rand() % delta) - delta/2; \n    tb += (rand() % delta) - delta/2; \n\n    tr = clampZeroTo255(tr);\n    tg = clampZeroTo255(tg);\n    tb = clampZeroTo255(tb);\n\n    // Avoid going too dark \n    if (tr + tg + tb \x3c 150) {\n      if ((rand() % 100) \x3c 30) tr = 255;\n      else if ((rand() % 100) \x3c 50) tg = 255;\n      else tb = 255;\n    }\n  }\n\n  int x = 2;\n  int y = 1;\n  writeTime(x, y, tr, tg, tb, 255);\n}\n\n\n\n// ----------\n\nint main( int argc, char* args[] ) { \n\n  long totalTime = 0;\n  long frameCount = 0;\n\n  // Initialize\n  if (!init()) return 1;\n\n  load_files();\n\n  // Clear existing pixels to transparent\n  clearDisplay(0,0,0,0);\n\n  // Loop  \n  bool quit = false;\n  while( quit == false ) {\n    \n    //Update Screen \n    SDL_Flip(screen); \n  \n    //Pause \n    usleep(SPEED * 1000);\n\n    // Check input\n    while (SDL_PollEvent(&event)) {\n\n      // Check for close button press \n      if (event.type == SDL_QUIT) { \n        quit = true; \n      } \n    }\n\n    // Update\n    totalTime += SPEED;\n    frameCount++;\n    update(SPEED, totalTime, frameCount);  \n\n    // Draw\n    drawDisplay();\n\n  }\n\n  clean_up();\n  return 0; \n}\n\n\n\n","Z:8jj>e|1=3*2+d|2=2=1*2+1$    For Open /","Z:8jx>6|1=3=c-1*2+7$GL ES 2","Z:8k3>k|1=3=j*2|1+g*2+4$.0 programming:\n    "],"timeDeltas":[17,27,15,15332,143539,13873,6,6,7],"granularity":10,"actualEndNum":90,"apool":{"numToAttrib":{"0":["author","g.7adqe1th72vgygl8"],"1":["author","g.fgbk65v1gwktdgo5"],"2":["author","g.s2bud5tbeqc1y5gb"]},"nextNum":3},"backwardsChangesets":["Z:1c\x3c1b|3-1a-1$","Z:bh\x3ca5|3=1a=1|p-a5$","Z:bk\x3c3|1-3$","Z:1>bj*0|2+h*0+u|1+1*0|3+l|1+1*0|l+9j*0+1|1+1$/*\nCompile with \ng++ -o pidemo pidemo.cpp -lSDL\n\nCode (pidemo.cpp):\n\n\n#include \"SDL/SDL.h\" \n\nint main( int argc, char* args[] ) { \n  SDL_Surface* screen = NULL;\n\n  //Start SDL \n  SDL_Init( SDL_INIT_EVERYTHING ); \n\n //Set up screen\n  screen = SDL_SetVideoMode( 1024, 320, 32, SDL_SWSURFACE ); \n\n  //Update Screen \n  SDL_Flip(screen); \n  \n  //Pause \n  SDL_Delay(2000);\n\n  //Quit SDL \n  SDL_Quit(); \n  \n  return 0; \n}\n","Z:7uh\x3c7ug|d8-7ug$","Z:8jj\x3cp2|ek-8ji*1|d8+7ug$/*\nInformation radiator for raspberry PI.\n\nCompile with \ng++ -o piradiator piradiator.cpp -lSDL -lSDL_gfx\n\n*/\n\n#include \"SDL/SDL.h\" \n#include \"SDL/SDL_gfxPrimitives.h\" \n#include \x3cstring>\n#include \x3cstdlib.h>\n#include \x3ctime.h>\n#include \x3cctime>\n\n//Screen attributes \nconst int SCREEN_WIDTH = 800; \nconst int SCREEN_HEIGHT = 240; \nconst int SCREEN_BPP = 32; \n\nconst int SPEED = 100; \n\nSDL_Surface *screen = NULL;\n\nSDL_Event event;\n\nconst int DISPLAY_W = 48; \nconst int DISPLAY_H = 9; \n\nconst int DISPLAY_PIXEL_W = SCREEN_WIDTH / DISPLAY_W; \nconst int DISPLAY_PIXEL_H = SCREEN_HEIGHT / DISPLAY_H; \n\nconst int DISPLAY_SIZE = DISPLAY_W * DISPLAY_H;\nint display[DISPLAY_SIZE];\nint display2[DISPLAY_SIZE];\n\nconst int CHAR_W = 5; \nconst int CHAR_H = 7; \n\nint oldSecond = -1;\n\nint char0[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char1[] = {0, 0, 1, 0, 0,\n                 0, 1, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0 };\n\nint char2[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 1, 0, 0, 0,\n   1, 1, 1, 1, 1 }; \n\nint char3[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char4[] = \n  {1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1 }; \n\nint char5[] = \n  {1, 1, 1, 1, 1,\n   1, 0, 0, 0, 0,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char6[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char7[] = \n  {1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0 }; \n\nint char8[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char9[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint charColon[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nint charSpace[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nbool init() { \n  // Init SDL\n  if (SDL_Init(SDL_INIT_EVERYTHING) == -1) { \n    return false; \n  } \n\n  // Set up the screen \n  screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, SDL_SWSURFACE); \n\n  // If there was an error in setting up the screen \n  if (screen == NULL) { return false; } \n\n  // Set the window caption \n  SDL_WM_SetCaption(\"PiRadiator\", NULL); \n\n  // Init display\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display[i] = 0;\n  } \n\n  // Init random\n  srand(time(NULL)); \n\n  // If everything initialized fine \n  return true; \n}\n\nvoid load_files() {\n}\n\nvoid clean_up() { \n   SDL_Quit(); \n}\n\n\nint clampZeroTo255(int v) {\n  if (v \x3c 0) return 0;\n  else if (v > 255) return 255;\n  else return v;\n}\n\nint colorRgb(int r, int g, int b) {\n  return SDL_MapRGB(screen->format, r, g, b);\n}\n\nint colorRgba(int r, int g, int b, int a) {\n  return SDL_MapRGBA(screen->format, r, g, b, a);\n}\n\nvoid fillRect(int x, int y, int w, int h, int color) {\n  SDL_Rect rect = {x,y,w,h};\n  SDL_FillRect(screen, &rect, color);\n}\n\n\nvoid drawDisplayPixel(int x, int y, int color) {  \n\n  int r = (color >> 24) & 0xFF;\n  int g = (color >> 16) & 0xFF;\n  int b = (color >> 8) & 0xFF;\n  int a = (color >> 0) & 0xFF;\n\n  int x1 = x * DISPLAY_PIXEL_W;\n  int y1 = y * DISPLAY_PIXEL_H;\n  int x2 = x1 + DISPLAY_PIXEL_W;\n  int y2 = y1 + DISPLAY_PIXEL_H;\n\n  int w = DISPLAY_PIXEL_W / 2;\n  int h = DISPLAY_PIXEL_H / 2;\n\n\n  int lum1 = 50;\n  int lum2 = 80;\n  int lum3 = 100;\n\n  int border1 = 1;\n  int border2 = 2;\n  int border3 = 4;\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border1, h-border1, r*lum1/100, g*lum1/100, b*lum1/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border2, h-border2, r*lum2/100, g*lum2/100, b*lum2/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border3, h-border3, r*lum3/100, g*lum3/100, b*lum3/100, 255);\n}\n\nint makeDisplayColor(int r, int g, int b, int a) {\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n\n    return (r \x3c\x3c 24) | (g \x3c\x3c 16) | (b \x3c\x3c 8) | (a);\n}\n\nvoid setPixel(int x, int y, int r, int g, int b, int a) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = makeDisplayColor(r, g, b, a);\n  }   \n}\n\nvoid setPixelColor(int x, int y, int color) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = color;\n  }   \n}\n\nvoid clearDisplay(int r, int g, int b, int a) {\n  int color = makeDisplayColor(r, g, b, a);\n\n  for (int i = 0; i \x3c DISPLAY_W * DISPLAY_H; i++) {\n    display[i] = color;\n  }\n}\n\nvoid clearScreen(int color) {\n  SDL_FillRect(screen, NULL, color);\n}\n\n\nvoid drawDisplay() {\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      int col = display[y * DISPLAY_W + x];\n      if (col != 0) {\n        drawDisplayPixel(x, y, col);\n      }\n    }\n  }\n}\n\nvoid writeSprite(int xp, int yp, int *pic, int w, int h, int r, int g, int b, int a) {\n\n  int col = makeDisplayColor(r, g, b, a);\n\n  for (int y = yp; y \x3c yp + h; y++) {\n    for (int x = xp; x \x3c xp + w; x++) {\n      int idx = (y - yp) * w + (x - xp);\n      if (pic[idx] > 0) setPixelColor(x, y, col);\n    }\n  } \n}\n\nvoid writeChar(int x, int y, int r, int g, int b, int a, char c) {\n  int col = makeDisplayColor(r, g, b, a);\n\n  switch (c) {\n    case '0': writeSprite(x, y, char0, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '1': writeSprite(x, y, char1, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '2': writeSprite(x, y, char2, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '3': writeSprite(x, y, char3, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '4': writeSprite(x, y, char4, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '5': writeSprite(x, y, char5, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '6': writeSprite(x, y, char6, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '7': writeSprite(x, y, char7, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '8': writeSprite(x, y, char8, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '9': writeSprite(x, y, char9, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ':': writeSprite(x, y, charColon, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ' ': writeSprite(x, y, charSpace, CHAR_W, CHAR_H, r, g, b, a); break;\n    default: ;\n  }\n}\n\nvoid writeNumber(int x, int y, int r, int g, int b, int a, int num, int digits, int spacing) {\n  bool numEncountered = false; \n  int xPos = x;\n  for (int digit = digits - 1; digit >= 0; digit--) {\n    int divider = 1;\n    for (int i = 0; i \x3c digit; i++) {\n      divider *= 10;\n    }\n\n    int d = (num / divider) % 10;         \n    numEncountered = numEncountered || (d != 0);\n\n    /* Uncomment to skip leading zeroes\n    if (numEncountered || digit == 0) {\n    */\n      writeChar(xPos, y, r, g, b, a, '0' + d);\n    /*\n    }\n    */\n \n    xPos += CHAR_W + spacing;\n  }\n}\n\n\n// ---------\n\nvoid move(int dx, int dy) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display2[i] = display[i];\n  }\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      setPixelColor(x + dx, y + dy, display2[y * DISPLAY_W + x]);\n    }\n  }\n}\n\nvoid fade(int fadeAmount) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    int color = display[i];\n    int r =  (color >> 24) & 0xFF;\n    int g =  (color >> 16) & 0xFF;\n    int b =  (color >> 8) & 0xFF;\n    int a =  (color >> 0) & 0xFF;\n    r = r * fadeAmount / 100;    \n    g = g * fadeAmount / 100;    \n    b = b * fadeAmount / 100;\n    a = 255;\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n    display[i] = ((r & 0xFF) \x3c\x3c 24) | ((g & 0xFF) \x3c\x3c 16) | ((b & 0xFF) \x3c\x3c 8) | ((a & 0xFF) \x3c\x3c 0);   \n  }    \n}\n\nint getSecond() {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  return ltm->tm_sec;\n}\n\nvoid writeTime(int x, int y, int r, int g, int b, int a) {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  \n  int spacing = 2;\n  int numW = CHAR_W * 2 + spacing;\n  int xPos = x;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_hour, 2, spacing);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':');\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_min, 2, spacing);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':');\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_sec, 2, spacing);\n}\n\nint tr = 255;\nint tg = 0;\nint tb = 0;\n\nvoid update(int timeDelta, long totalTime, long frameCount) {\n\n  // Fadeout\n  //boxRGBA(screen, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0,0,0, 10);\n  move(0, 1);\n  fade(35);\n\n  int second = getSecond();  \n  if (oldSecond != second) { \n    oldSecond = second;\n\n    int delta = 100;\n\n    tr += (rand() % delta) - delta/2; \n    tg += (rand() % delta) - delta/2; \n    tb += (rand() % delta) - delta/2; \n\n    tr = clampZeroTo255(tr);\n    tg = clampZeroTo255(tg);\n    tb = clampZeroTo255(tb);\n  }\n\n  int x = 2;\n  int y = 1;\n  writeTime(x, y, tr, tg, tb, 255);\n}\n\n\n\n// ----------\n\nint main( int argc, char* args[] ) { \n\n  long totalTime = 0;\n  long frameCount = 0;\n\n  // Initialize\n  if (!init()) return 1;\n\n  load_files();\n\n  // Clear existing pixels to transparent\n  clearDisplay(0,0,0,0);\n\n  // Loop  \n  bool quit = false;\n  while( quit == false ) {\n    \n    //Update Screen \n    SDL_Flip(screen); \n  \n    //Pause \n    usleep(SPEED * 1000);\n\n    // Check input\n    while (SDL_PollEvent(&event)) {\n\n      // Check for close button press \n      if (event.type == SDL_QUIT) { \n        quit = true; \n      } \n    }\n\n    // Update\n    totalTime += SPEED;\n    frameCount++;\n    update(SPEED, totalTime, frameCount);  \n\n    // Draw\n    drawDisplay();\n\n  }\n\n  clean_up();\n  return 0; \n}\n\n\n\n\n","Z:8jx\x3ce|1=3-d|2=2=1-1$","Z:8k3\x3c6|1=3=c-7*2+1$ ","Z:8kn\x3ck|1=3=j|1-g-4$"]},{"start":90,"forwardsChangesets":["Z:8kn>2s|2=12=4*0+2s$http://benosteen.wordpress.com/2012/04/27/using-opengl-es-2-0-on-the-raspberry-pi-without-x-windows/","Z:8nf>1|2=12*0*1*2+1$*","Z:8ng\x3c1|3=40|1-1$","Z:8nf>0*3|4=43$"],"timeDeltas":[1,5,6,8],"granularity":1,"actualEndNum":94,"apool":{"numToAttrib":{"0":["author","g.s2bud5tbeqc1y5gb"],"1":["insertorder","first"],"2":["list","bullet1"],"3":["author",""]},"nextNum":4},"backwardsChangesets":["Z:8nf\x3c2s|2=12=4-2s$","Z:8ng\x3c1|2=12-1$","Z:8nf>1|3=40*0|1+1$\n","Z:8nf>0*0|4=43$"]}],"sliderEnabled":true,"colorPalette":["#ffc7c7","#fff1c7","#e3ffc7","#c7ffd5","#c7ffff","#c7d5ff","#e3c7ff","#ffc7f1","#ff8f8f","#ffe38f","#c7ff8f","#8fffab","#8fffff","#8fabff","#c78fff","#ff8fe3","#d97979","#d9c179","#a9d979","#79d991","#79d9d9","#7991d9","#a979d9","#d979c1","#d9a9a9","#d9cda9","#c1d9a9","#a9d9b5","#a9d9d9","#a9b5d9","#c1a9d9","#d9a9cd"],"supportsSlider":true,"currentTime":1354988688109,"savedRevisions":[{"id":"zdAi60oxPH","timestamp":1354816093981,"revNum":"31","savedById":"g.7adqe1th72vgygl8","label":"Revision 1","savedBy":"zzorn"}],"initialPadContents":"/*\n    For OpenGL ES 2.0 programming:\n*    http://benosteen.wordpress.com/2012/04/27/using-opengl-es-2-0-on-the-raspberry-pi-without-x-windows/\n*/\n\n\n\n/*\nInformation radiator for raspberry PI.\n\nCompile with \ng++ -o piradiator piradiator.cpp -lSDL -lSDL_gfx\n\n*/\n\n#include \"SDL/SDL.h\" \n#include \"SDL/SDL_gfxPrimitives.h\" \n#include \x3cstring>\n#include \x3cstdlib.h>\n#include \x3ctime.h>\n#include \x3cctime>\n\n//Screen attributes \nconst int SCREEN_WIDTH = 800; \nconst int SCREEN_HEIGHT = 240; \nconst int SCREEN_BPP = 32; \n\nconst int SPEED = 100; \n\nSDL_Surface *screen = NULL;\n\nSDL_Event event;\n\nconst int DISPLAY_W = 48; \nconst int DISPLAY_H = 9; \n\nconst int DISPLAY_PIXEL_W = SCREEN_WIDTH / DISPLAY_W; \nconst int DISPLAY_PIXEL_H = SCREEN_HEIGHT / DISPLAY_H; \n\nconst int DISPLAY_SIZE = DISPLAY_W * DISPLAY_H;\nint display[DISPLAY_SIZE];\nint display2[DISPLAY_SIZE];\n\nconst int CHAR_W = 5; \nconst int CHAR_H = 7; \n\nint oldSecond = -1;\n\nint char0[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char1[] = {0, 0, 1, 0, 0,\n                 0, 1, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0,\n                 0, 0, 1, 0, 0 };\n\nint char2[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 1, 0, 0, 0,\n   1, 1, 1, 1, 1 }; \n\nint char3[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char4[] = \n  {1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 0, 1 }; \n\nint char5[] = \n  {1, 1, 1, 1, 1,\n   1, 0, 0, 0, 0,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char6[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 0,\n   1, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char7[] = \n  {1, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   0, 0, 0, 1, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 1, 0, 0 }; \n\nint char8[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint char9[] = \n  {0, 1, 1, 1, 0,\n   1, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 1,\n   0, 0, 0, 0, 1,\n   1, 0, 0, 0, 1,\n   0, 1, 1, 1, 0 }; \n\nint charColon[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 1, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nint charSpace[] = \n  {0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0 }; \n\nint charInvader1[] = \n  {1, 0, 0, 0, 1,\n   0, 1, 0, 1, 0,\n   1, 1, 1, 1, 1,\n   1, 0, 1, 0, 1,\n   1, 1, 1, 1, 1,\n   1, 0, 0, 0, 1,\n   1, 1, 0, 1, 1 }; \n\nbool init() { \n  // Init SDL\n  if (SDL_Init(SDL_INIT_EVERYTHING) == -1) { \n    return false; \n  } \n\n  // Set up the screen \n  screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, SDL_SWSURFACE); \n\n  // If there was an error in setting up the screen \n  if (screen == NULL) { return false; } \n\n  // Set the window caption \n  SDL_WM_SetCaption(\"PiRadiator\", NULL); \n\n  // Init display\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display[i] = 0;\n  } \n\n  // Init random\n  srand(time(NULL)); \n\n  // If everything initialized fine \n  return true; \n}\n\nvoid load_files() {\n}\n\nvoid clean_up() { \n   SDL_Quit(); \n}\n\n\nint clampZeroTo255(int v) {\n  if (v \x3c 0) return 0;\n  else if (v > 255) return 255;\n  else return v;\n}\n\nint colorRgb(int r, int g, int b) {\n  return SDL_MapRGB(screen->format, r, g, b);\n}\n\nint colorRgba(int r, int g, int b, int a) {\n  return SDL_MapRGBA(screen->format, r, g, b, a);\n}\n\nvoid fillRect(int x, int y, int w, int h, int color) {\n  SDL_Rect rect = {x,y,w,h};\n  SDL_FillRect(screen, &rect, color);\n}\n\n\nvoid drawDisplayPixel(int x, int y, int color) {  \n\n  int r = (color >> 24) & 0xFF;\n  int g = (color >> 16) & 0xFF;\n  int b = (color >> 8) & 0xFF;\n  int a = (color >> 0) & 0xFF;\n\n  int x1 = x * DISPLAY_PIXEL_W;\n  int y1 = y * DISPLAY_PIXEL_H;\n  int x2 = x1 + DISPLAY_PIXEL_W;\n  int y2 = y1 + DISPLAY_PIXEL_H;\n\n  int w = DISPLAY_PIXEL_W / 2;\n  int h = DISPLAY_PIXEL_H / 2;\n\n\n  int lum1 = 50;\n  int lum2 = 80;\n  int lum3 = 100;\n\n  int border1 = 1;\n  int border2 = 2;\n  int border3 = 4;\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border1, h-border1, r*lum1/100, g*lum1/100, b*lum1/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border2, h-border2, r*lum2/100, g*lum2/100, b*lum2/100, 255);\n\n  filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border3, h-border3, r*lum3/100, g*lum3/100, b*lum3/100, 255);\n}\n\nint makeDisplayColor(int r, int g, int b, int a) {\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n\n    return (r \x3c\x3c 24) | (g \x3c\x3c 16) | (b \x3c\x3c 8) | (a);\n}\n\nvoid setPixel(int x, int y, int r, int g, int b, int a) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = makeDisplayColor(r, g, b, a);\n  }   \n}\n\nvoid setPixelColor(int x, int y, int color) {\n  if (x >= 0 && x \x3c DISPLAY_W && y >= 0 && y \x3c DISPLAY_H) {\n    display[y * DISPLAY_W + x] = color;\n  }   \n}\n\nvoid clearDisplay(int r, int g, int b, int a) {\n  int color = makeDisplayColor(r, g, b, a);\n\n  for (int i = 0; i \x3c DISPLAY_W * DISPLAY_H; i++) {\n    display[i] = color;\n  }\n}\n\nint getSecond() {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  return ltm->tm_sec;\n}\n\n\nvoid clearScreen(int color) {\n  SDL_FillRect(screen, NULL, color);\n}\n\n\nvoid drawDisplay() {\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      int col = display[y * DISPLAY_W + x];\n      if (col != 0) {\n        drawDisplayPixel(x, y, col);\n      }\n    }\n  }\n}\n\nvoid writeSprite(int xp, int yp, int *pic, int w, int h, int r, int g, int b, int a) {\n\n  int col = makeDisplayColor(r, g, b, a);\n\n  for (int y = yp; y \x3c yp + h; y++) {\n    for (int x = xp; x \x3c xp + w; x++) {\n      int idx = (y - yp) * w + (x - xp);\n      if (pic[idx] > 0) setPixelColor(x, y, col);\n    }\n  } \n}\n\nvoid writeChar(int x, int y, int r, int g, int b, int a, char c, bool invaders) {\n  int col = makeDisplayColor(r, g, b, a);\n\n  if (invaders && getSecond() == x / 5) {\n    c = '*';\n  }\n\n\n  switch (c) {\n    case '0': writeSprite(x, y, char0, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '1': writeSprite(x, y, char1, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '2': writeSprite(x, y, char2, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '3': writeSprite(x, y, char3, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '4': writeSprite(x, y, char4, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '5': writeSprite(x, y, char5, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '6': writeSprite(x, y, char6, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '7': writeSprite(x, y, char7, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '8': writeSprite(x, y, char8, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '9': writeSprite(x, y, char9, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ':': writeSprite(x, y, charColon, CHAR_W, CHAR_H, r, g, b, a); break;\n    case ' ': writeSprite(x, y, charSpace, CHAR_W, CHAR_H, r, g, b, a); break;\n    case '*': writeSprite(x, y, charInvader1, CHAR_W, CHAR_H, r, g, b, a); break;\n    default: ;\n  }\n}\n\nvoid writeNumber(int x, int y, int r, int g, int b, int a, int num, int digits, int spacing, bool invaders) {\n  bool numEncountered = false; \n  int xPos = x;\n  for (int digit = digits - 1; digit >= 0; digit--) {\n    int divider = 1;\n    for (int i = 0; i \x3c digit; i++) {\n      divider *= 10;\n    }\n\n    int d = (num / divider) % 10;         \n    numEncountered = numEncountered || (d != 0);\n\n    char ch = '0' + d;\n\n \n\n    /* Uncomment to skip leading zeroes\n    if (numEncountered || digit == 0) {\n    */\n      writeChar(xPos, y, r, g, b, a, ch, invaders);\n    /*\n    }\n    */\n \n    xPos += CHAR_W + spacing;\n  }\n}\n\n\n// ---------\n\nvoid move(int dx, int dy) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    display2[i] = display[i];\n  }\n\n  for (int y = 0; y \x3c DISPLAY_H; y++) {\n    for (int x = 0; x \x3c DISPLAY_W; x++) {\n      setPixelColor(x + dx, y + dy, display2[y * DISPLAY_W + x]);\n    }\n  }\n}\n\nvoid fade(int fadeAmount) {\n  for (int i = 0; i \x3c DISPLAY_SIZE; i++) {\n    int color = display[i];\n    int r =  (color >> 24) & 0xFF;\n    int g =  (color >> 16) & 0xFF;\n    int b =  (color >> 8) & 0xFF;\n    int a =  (color >> 0) & 0xFF;\n    r = r * fadeAmount / 100;    \n    g = g * fadeAmount / 100;    \n    b = b * fadeAmount / 100;\n    a = 255;\n    r = clampZeroTo255(r);\n    g = clampZeroTo255(g);\n    b = clampZeroTo255(b);\n    display[i] = ((r & 0xFF) \x3c\x3c 24) | ((g & 0xFF) \x3c\x3c 16) | ((b & 0xFF) \x3c\x3c 8) | ((a & 0xFF) \x3c\x3c 0);   \n  }    \n}\n\nbool invaders = false;\n\nvoid writeTime(int x, int y, int r, int g, int b, int a) {\n  time_t now = time(0);\n  tm *ltm = localtime(&now);\n  \n  // Check if we got invaded\n  if ((rand() % 100) \x3c= 1) {\n    invaders = true;\n  }\n  if ((rand() % 100) \x3c= 20) {\n    invaders = false;\n  }\n  if (ltm->tm_hour > 3 && ltm->tm_hour \x3c 7 && (rand() % 100) \x3c 20) {\n    invaders = true;\n  }\n\n  int spacing = 2;\n  int numW = CHAR_W * 2 + spacing;\n  int xPos = x;\n  int digits = 2;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_hour, digits, spacing, invaders);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':', false);\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_min, digits, spacing, invaders);\n  xPos += numW;\n  writeChar(xPos, y, r, g, b, 255, ':', false);\n  xPos += CHAR_W;\n  writeNumber(xPos, y, r, g, b, 255, ltm->tm_sec, digits, spacing, invaders);\n}\n\nint tr = 255;\nint tg = 0;\nint tb = 0;\n\nvoid update(int timeDelta, long totalTime, long frameCount) {\n\n  // Fadeout\n  //boxRGBA(screen, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0,0,0, 10);\n  move(0, 1);\n  fade(35);\n\n  int second = getSecond();  \n  if (oldSecond != second) { \n    oldSecond = second;\n  \n    // Change color\n    int delta = 100;\n    \n    tr += (rand() % delta) - delta/2; \n    tg += (rand() % delta) - delta/2; \n    tb += (rand() % delta) - delta/2; \n\n    tr = clampZeroTo255(tr);\n    tg = clampZeroTo255(tg);\n    tb = clampZeroTo255(tb);\n\n    // Avoid going too dark \n    if (tr + tg + tb \x3c 150) {\n      if ((rand() % 100) \x3c 30) tr = 255;\n      else if ((rand() % 100) \x3c 50) tg = 255;\n      else tb = 255;\n    }\n  }\n\n  int x = 2;\n  int y = 1;\n  writeTime(x, y, tr, tg, tb, 255);\n}\n\n\n\n// ----------\n\nint main( int argc, char* args[] ) { \n\n  long totalTime = 0;\n  long frameCount = 0;\n\n  // Initialize\n  if (!init()) return 1;\n\n  load_files();\n\n  // Clear existing pixels to transparent\n  clearDisplay(0,0,0,0);\n\n  // Loop  \n  bool quit = false;\n  while( quit == false ) {\n    \n    //Update Screen \n    SDL_Flip(screen); \n  \n    //Pause \n    usleep(SPEED * 1000);\n\n    // Check input\n    while (SDL_PollEvent(&event)) {\n\n      // Check for close button press \n      if (event.type == SDL_QUIT) { \n        quit = true; \n      } \n    }\n\n    // Update\n    totalTime += SPEED;\n    frameCount++;\n    update(SPEED, totalTime, frameCount);  \n\n    // Draw\n    drawDisplay();\n\n  }\n\n  clean_up();\n  return 0; \n}\n\n\n\n","padIdForUrl":"hacklab-piradiator"};
  // ]]>
</script>
    <script type="text/javascript" src="http://www.kirjoitusalusta.fi/static/compressed/280a28a317ae35527a244df56efbf0f4.js"></script>
    

  </head>

  <body id="padbody" class="limwidth nonpropad nonprouser">

    















  <div id="padpage">
    <div id="padtop">
      <div id="topbar">
	
	<div id="topbarleft"><!-- --></div>
	
	
	<div id="topbarright"><!-- --></div>
	
	
	<div id="topbarcenter">

	  <a href="http://www.kirjoitusalusta.fi/" id="topbarBrand">Kirjoitusalusta.fi</a>
        

            
	<div id="fullscreen" onclick="$('body').toggleClass('maximized');">Koko ruutu</div>

	  <a href="javascript:void(0);" onclick="$('body').toggleClass('maximized');" id="topbarmaximize" title="Koon st"></a>
	</div>
        
	<div id="specialkeyarea"><!-- --></div>
      </div>
      <div id="alertbar">
	<div id="servermsg">
	  <h3>Server Notice<span id="servermsgdate"><!-- --></span>:</h3>
	  <a id="hidetopmsg" href="javascript: void pad.hideServerMessage()">hide</a>
	  <p id="servermsgtext"><!-- --></p>
	</div>
      </div>
      <div id="navigation">
        
      </div>

      <div id="docbar" class="menu">
	<table border="0" cellpadding="0" cellspacing="0" width="100%" id="docbartable">
	  <tr>
	    <td><img src="../pad/roundcorner_left.gif"></td>
            
  <td id="docbarpadtitle" title="Julkinen ty&ouml;tila: Julkinen ty&ouml;tila"><span>Julkinen ty&ouml;tila</span></td>

	    <td width="100%">&nbsp;</td>
            
	    
	    <td><img src="../pad/roundcorner_right_orange.gif"></td>
	  </tr>
	</table>
        
        
        
      </div><!-- /docbar -->
    </div>

    
  <div id="timeslider-wrapper">
  <div id="error" style="display: none">Yhteydess on hiriit. <a href="latest.html">Yhdist uudelleen</a>.</div>
  <div id="timeslider" unselectable="on" style="display: none">
    <div id="timeslider-left"></div>
    <div id="timeslider-right"></div>
    <div id="timer">12/08/2012 19:44:48</div>
    <div id="timeslider-slider">
      <div id="ui-slider-handle">

      </div>
      <div id="ui-slider-bar">

      </div>
    </div>
    <div id="playpause_button">
      <div id="playpause_button_icon" class=""></div>
    </div>
    <div id="steppers">
      <div class="stepper" id="leftstar"></div>
      <div class="stepper" id="rightstar"></div>
      <div class="stepper" id="leftstep"></div>
      <div class="stepper" id="rightstep"></div>
    </div>
  </div>
  </div>


    <div id="padmain">
      <script>
	$(document).ready(function () {
	  makeResizableHPane("#padeditor", "#vdraggie", "#padsidebar", 0, 0, 10, -22);
	});
      </script>
      <div id="padeditor">
	<div id="editbar" class="disabledtoolbar">
          <div id="editbarinner">
	    
	    <div id="editbarleft"><!-- --></div>
	    
	    <div id="editbarright"><!-- --></div>      
	    
	    <div id="editbarinner">
	      <table cellpadding="0" cellspacing="0" border = "0" id="editbartable">
		<tr>
		  
  <td>
    <h1>
      Julkinen ty&ouml;tila
      <span id="revision_label">Latest text of pad hacklab-piradiator</span>
      <span id="revision_date">
	Tallennettu
	Joulukuu
	8,
	2012
      </span>
    </h1>
  </td>
  

		  
		  <td width="100%">&nbsp;</td>
		</tr>
	      </table>
	      <table cellpadding="0" cellspacing="0" border = "0" id="editbarsavetable">
		<tr>
		  
		  
  
<td>&nbsp;&nbsp;</td>
<td><img src="../pad/editbar_groupleft.gif" width="2" height="24"></td>
<td class="editbarbutton editbargroupsfirst">
  <a href="http://www.kirjoitusalusta.fi/ep/copyPad?old=hacklab-piradiator/latest&amp;old_rev=undefined" title="Copy pad"><img src="../copyPad/editbar_copy.gif"></a>
</td>
<!--
<td class="editbarbutton">
  <a href="/ep/search?linksto=hacklab-piradiator/latest" title="Find links to this pad (including copies of this pad)"><img src="/static/html/plugins/copyPad/editbar_find_links.gif"></a>
</td>
-->
<td><img src="../pad/editbar_groupright.gif" width="2" height="24"></td>
<td>&nbsp;&nbsp;</td>
 

		</tr>
	      </table>
	      
	      
	    </div>
          </div>
	</div>
	<div id="editorcontainerbox">
  <div id="padcontent">
    <div class="ace-line"><span class="">/*</span></div>
<div class="ace-line"><span class="">&nbsp;&nbsp;&nbsp; For OpenGL ES 2.0 programming:</span></div>
<div class="ace-line"><ul class="list-bullet1"><li><span class="">&nbsp;&nbsp;&nbsp; </span><span class=" url"><a href="http://benosteen.wordpress.com/2012/04/27/using-opengl-es-2-0-on-the-raspberry-pi-without-x-windows/">http://benosteen.wordpress.com/2012/04/27/using-opengl-es-2-0-on-the-raspberry-pi-without-x-windows/</a></span></li></ul></div>
<div class="ace-line"><span class="">*/</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">/*</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">Information radiator for raspberry PI.</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">Compile with&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">g++ -o piradiator piradiator.cpp -lSDL -lSDL_gfx</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">*/</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">#include &#34;SDL/SDL.h&#34;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">#include &#34;SDL/SDL_gfxPrimitives.h&#34;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">#include &lt;string&gt;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">#include &lt;stdlib.h&gt;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">#include &lt;time.h&gt;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">#include &lt;ctime&gt;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">//Screen attributes&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">const int SCREEN_WIDTH = 800;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">const int SCREEN_HEIGHT = 240;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">const int SCREEN_BPP = 32;&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">const int SPEED = 100;&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">SDL_Surface *screen = NULL;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">SDL_Event event;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">const int DISPLAY_W = 48;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">const int DISPLAY_H = 9;&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">const int DISPLAY_PIXEL_W = SCREEN_WIDTH / DISPLAY_W;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">const int DISPLAY_PIXEL_H = SCREEN_HEIGHT / DISPLAY_H;&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">const int DISPLAY_SIZE = DISPLAY_W * DISPLAY_H;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int display[DISPLAY_SIZE];</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int display2[DISPLAY_SIZE];</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">const int CHAR_W = 5;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">const int CHAR_H = 7;&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int oldSecond = -1;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int char0[] =&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; {0, 1, 1, 1, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 1, 1, 1, 0 };&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int char1[] = {0, 0, 1, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 1, 1, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 1, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 1, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 1, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 1, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 1, 0, 0 };</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int char2[] =&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; {0, 1, 1, 1, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 1, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 1, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 1, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 1, 1, 1, 1 };&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int char3[] =&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; {0, 1, 1, 1, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 1, 1, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 1, 1, 1, 0 };&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int char4[] =&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; {1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 1, 1, 1, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 1 };&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int char5[] =&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; {1, 1, 1, 1, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 1, 1, 1, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 1, 1, 1, 0 };&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int char6[] =&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; {0, 1, 1, 1, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 1, 1, 1, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 1, 1, 1, 0 };&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int char7[] =&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; {1, 1, 1, 1, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 1, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 1, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 1, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 1, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 1, 0, 0 };&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int char8[] =&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; {0, 1, 1, 1, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 1, 1, 1, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 1, 1, 1, 0 };&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int char9[] =&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; {0, 1, 1, 1, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 1, 1, 1, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 1, 1, 1, 0 };&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int charColon[] =&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; {0, 0, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 1, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 1, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 0 };&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int charSpace[] =&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; {0, 0, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 0, 0, 0, 0 };&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int charInvader1[] =&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; {1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 0, 1, 0, 1, 0,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 1, 1, 1, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 1, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 1, 1, 1, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 0, 0, 0, 1,</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; 1, 1, 0, 1, 1 };&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">bool init() {&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; // Init SDL</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; if (SDL_Init(SDL_INIT_EVERYTHING) == -1) {&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; return false;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; // Set up the screen&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, SDL_SWSURFACE);&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; // If there was an error in setting up the screen&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; if (screen == NULL) { return false; }&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; // Set the window caption&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; SDL_WM_SetCaption(&#34;PiRadiator&#34;, NULL);&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; // Init display</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; for (int i = 0; i &lt; DISPLAY_SIZE; i++) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; display[i] = 0;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; // Init random</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; srand(time(NULL));&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; // If everything initialized fine&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; return true;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void load_files() {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void clean_up() {&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp; SDL_Quit();&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int clampZeroTo255(int v) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; if (v &lt; 0) return 0;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; else if (v &gt; 255) return 255;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; else return v;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int colorRgb(int r, int g, int b) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; return SDL_MapRGB(screen-&gt;format, r, g, b);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int colorRgba(int r, int g, int b, int a) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; return SDL_MapRGBA(screen-&gt;format, r, g, b, a);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void fillRect(int x, int y, int w, int h, int color) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; SDL_Rect rect = {x,y,w,h};</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; SDL_FillRect(screen, &amp;rect, color);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void drawDisplayPixel(int x, int y, int color) {&nbsp;&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int r = (color &gt;&gt; 24) &amp; 0xFF;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int g = (color &gt;&gt; 16) &amp; 0xFF;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int b = (color &gt;&gt; 8) &amp; 0xFF;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int a = (color &gt;&gt; 0) &amp; 0xFF;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int x1 = x * DISPLAY_PIXEL_W;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int y1 = y * DISPLAY_PIXEL_H;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int x2 = x1 + DISPLAY_PIXEL_W;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int y2 = y1 + DISPLAY_PIXEL_H;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int w = DISPLAY_PIXEL_W / 2;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int h = DISPLAY_PIXEL_H / 2;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int lum1 = 50;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int lum2 = 80;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int lum3 = 100;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int border1 = 1;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int border2 = 2;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int border3 = 4;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border1, h-border1, r*lum1/100, g*lum1/100, b*lum1/100, 255);</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border2, h-border2, r*lum2/100, g*lum2/100, b*lum2/100, 255);</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; filledEllipseRGBA(screen, (x1+x2)/2, (y1+y2)/2, w-border3, h-border3, r*lum3/100, g*lum3/100, b*lum3/100, 255);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int makeDisplayColor(int r, int g, int b, int a) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; r = clampZeroTo255(r);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; g = clampZeroTo255(g);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; b = clampZeroTo255(b);</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; return (r &lt;&lt; 24) | (g &lt;&lt; 16) | (b &lt;&lt; 8) | (a);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void setPixel(int x, int y, int r, int g, int b, int a) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; if (x &gt;= 0 &amp;&amp; x &lt; DISPLAY_W &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; DISPLAY_H) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; display[y * DISPLAY_W + x] = makeDisplayColor(r, g, b, a);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }&nbsp;&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void setPixelColor(int x, int y, int color) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; if (x &gt;= 0 &amp;&amp; x &lt; DISPLAY_W &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; DISPLAY_H) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; display[y * DISPLAY_W + x] = color;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }&nbsp;&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void clearDisplay(int r, int g, int b, int a) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int color = makeDisplayColor(r, g, b, a);</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; for (int i = 0; i &lt; DISPLAY_W * DISPLAY_H; i++) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; display[i] = color;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int getSecond() {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; time_t now = time(0);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; tm *ltm = localtime(&amp;now);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; return ltm-&gt;tm_sec;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void clearScreen(int color) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; SDL_FillRect(screen, NULL, color);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void drawDisplay() {</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; for (int y = 0; y &lt; DISPLAY_H; y++) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; for (int x = 0; x &lt; DISPLAY_W; x++) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int col = display[y * DISPLAY_W + x];</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (col != 0) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawDisplayPixel(x, y, col);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; }</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void writeSprite(int xp, int yp, int *pic, int w, int h, int r, int g, int b, int a) {</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int col = makeDisplayColor(r, g, b, a);</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; for (int y = yp; y &lt; yp + h; y++) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; for (int x = xp; x &lt; xp + w; x++) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int idx = (y - yp) * w + (x - xp);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pic[idx] &gt; 0) setPixelColor(x, y, col);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; }</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void writeChar(int x, int y, int r, int g, int b, int a, char c, bool invaders) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int col = makeDisplayColor(r, g, b, a);</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; if (invaders &amp;&amp; getSecond() == x / 5) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; c = &#39;*&#39;;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; switch (c) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; case &#39;0&#39;: writeSprite(x, y, char0, CHAR_W, CHAR_H, r, g, b, a); break;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; case &#39;1&#39;: writeSprite(x, y, char1, CHAR_W, CHAR_H, r, g, b, a); break;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; case &#39;2&#39;: writeSprite(x, y, char2, CHAR_W, CHAR_H, r, g, b, a); break;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; case &#39;3&#39;: writeSprite(x, y, char3, CHAR_W, CHAR_H, r, g, b, a); break;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; case &#39;4&#39;: writeSprite(x, y, char4, CHAR_W, CHAR_H, r, g, b, a); break;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; case &#39;5&#39;: writeSprite(x, y, char5, CHAR_W, CHAR_H, r, g, b, a); break;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; case &#39;6&#39;: writeSprite(x, y, char6, CHAR_W, CHAR_H, r, g, b, a); break;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; case &#39;7&#39;: writeSprite(x, y, char7, CHAR_W, CHAR_H, r, g, b, a); break;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; case &#39;8&#39;: writeSprite(x, y, char8, CHAR_W, CHAR_H, r, g, b, a); break;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; case &#39;9&#39;: writeSprite(x, y, char9, CHAR_W, CHAR_H, r, g, b, a); break;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; case &#39;:&#39;: writeSprite(x, y, charColon, CHAR_W, CHAR_H, r, g, b, a); break;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; case &#39; &#39;: writeSprite(x, y, charSpace, CHAR_W, CHAR_H, r, g, b, a); break;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; case &#39;*&#39;: writeSprite(x, y, charInvader1, CHAR_W, CHAR_H, r, g, b, a); break;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; default: ;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void writeNumber(int x, int y, int r, int g, int b, int a, int num, int digits, int spacing, bool invaders) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; bool numEncountered = false;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int xPos = x;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; for (int digit = digits - 1; digit &gt;= 0; digit--) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; int divider = 1;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; digit; i++) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; divider *= 10;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; }</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; int d = (num / divider) % 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; numEncountered = numEncountered || (d != 0);</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; char ch = &#39;0&#39; + d;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; /* Uncomment to skip leading zeroes</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; if (numEncountered || digit == 0) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; */</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeChar(xPos, y, r, g, b, a, ch, invaders);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; /*</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; }</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; */</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; xPos += CHAR_W + spacing;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">// ---------</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void move(int dx, int dy) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; for (int i = 0; i &lt; DISPLAY_SIZE; i++) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; display2[i] = display[i];</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; for (int y = 0; y &lt; DISPLAY_H; y++) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; for (int x = 0; x &lt; DISPLAY_W; x++) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setPixelColor(x + dx, y + dy, display2[y * DISPLAY_W + x]);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; }</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void fade(int fadeAmount) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; for (int i = 0; i &lt; DISPLAY_SIZE; i++) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; int color = display[i];</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; int r =&nbsp; (color &gt;&gt; 24) &amp; 0xFF;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; int g =&nbsp; (color &gt;&gt; 16) &amp; 0xFF;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; int b =&nbsp; (color &gt;&gt; 8) &amp; 0xFF;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; int a =&nbsp; (color &gt;&gt; 0) &amp; 0xFF;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; r = r * fadeAmount / 100;&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; g = g * fadeAmount / 100;&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; b = b * fadeAmount / 100;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; a = 255;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; r = clampZeroTo255(r);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; g = clampZeroTo255(g);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; b = clampZeroTo255(b);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; display[i] = ((r &amp; 0xFF) &lt;&lt; 24) | ((g &amp; 0xFF) &lt;&lt; 16) | ((b &amp; 0xFF) &lt;&lt; 8) | ((a &amp; 0xFF) &lt;&lt; 0);&nbsp;&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">bool invaders = false;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void writeTime(int x, int y, int r, int g, int b, int a) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; time_t now = time(0);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; tm *ltm = localtime(&amp;now);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; // Check if we got invaded</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; if ((rand() % 100) &lt;= 1) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; invaders = true;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; if ((rand() % 100) &lt;= 20) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; invaders = false;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; if (ltm-&gt;tm_hour &gt; 3 &amp;&amp; ltm-&gt;tm_hour &lt; 7 &amp;&amp; (rand() % 100) &lt; 20) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; invaders = true;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int spacing = 2;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int numW = CHAR_W * 2 + spacing;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int xPos = x;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int digits = 2;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; writeNumber(xPos, y, r, g, b, 255, ltm-&gt;tm_hour, digits, spacing, invaders);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; xPos += numW;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; writeChar(xPos, y, r, g, b, 255, &#39;:&#39;, false);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; xPos += CHAR_W;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; writeNumber(xPos, y, r, g, b, 255, ltm-&gt;tm_min, digits, spacing, invaders);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; xPos += numW;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; writeChar(xPos, y, r, g, b, 255, &#39;:&#39;, false);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; xPos += CHAR_W;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; writeNumber(xPos, y, r, g, b, 255, ltm-&gt;tm_sec, digits, spacing, invaders);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int tr = 255;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int tg = 0;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int tb = 0;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">void update(int timeDelta, long totalTime, long frameCount) {</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; // Fadeout</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; //boxRGBA(screen, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0,0,0, 10);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; move(0, 1);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; fade(35);</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int second = getSecond();&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; if (oldSecond != second) {&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; oldSecond = second;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; // Change color</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; int delta = 100;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; tr += (rand() % delta) - delta/2;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; tg += (rand() % delta) - delta/2;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; tb += (rand() % delta) - delta/2;&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; tr = clampZeroTo255(tr);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; tg = clampZeroTo255(tg);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; tb = clampZeroTo255(tb);</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; // Avoid going too dark&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; if (tr + tg + tb &lt; 150) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((rand() % 100) &lt; 30) tr = 255;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((rand() % 100) &lt; 50) tg = 255;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else tb = 255;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; }</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int x = 2;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; int y = 1;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; writeTime(x, y, tr, tg, tb, 255);</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">// ----------</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">int main( int argc, char* args[] ) {&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; long totalTime = 0;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; long frameCount = 0;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; // Initialize</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; if (!init()) return 1;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; load_files();</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; // Clear existing pixels to transparent</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; clearDisplay(0,0,0,0);</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; // Loop&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; bool quit = false;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; while( quit == false ) {</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; //Update Screen&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; SDL_Flip(screen);&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; //Pause&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; usleep(SPEED * 1000);</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; // Check input</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; while (SDL_PollEvent(&amp;event)) {</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Check for close button press&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (event.type == SDL_QUIT) {&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; quit = true;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; }</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; // Update</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; totalTime += SPEED;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; frameCount++;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; update(SPEED, totalTime, frameCount);&nbsp;&nbsp;</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; // Draw</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp;&nbsp;&nbsp; drawDisplay();</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; }</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; clean_up();</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">&nbsp; return 0;&nbsp;</span></div>
<div class="ace-line"><span class="author-g-fgbk65v1gwktdgo5">}</span></div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>
<div class="ace-line">&nbsp;</div>

  </div>
</div>
      </div><!-- /padeditor -->

      <div id="vdraggie"><!-- --></div>

      <div id="padsidebar">
  <div id="padsidebarfull">
    <div id="rightbar">
      <a id="viewlatest" href="latest.html">
      Nytetn uusin sislt</a><br>
      <a class="tlink" href="latest.html" thref="/ep/pad/view/hacklab-piradiator/rev.%revision%">Linkki thn versioon</a>
      <br><a class="tlink" href="../ro.kJM$KnyZ-ZmdPIAWE4v/latest.html" thref="/ep/pad/view/ro.kJM$KnyZ-ZmdPIAWE4v/rev.%revision%">Linkki katselutilaan</a><br><a href="../hacklab-piradiator.1.html">Siirry muokkaustilaan</a>
      <h2>Lataa muodossa:</h2>
      <img src="http://www.kirjoitusalusta.fi/static/img/may09/html.gif"><a class="tlink" href="latest%3Fformat=html.html" thref="/ep/pad/export/hacklab-piradiator/rev.%revision%?format=html">HTML</a><br>
      <img src="http://www.kirjoitusalusta.fi/static/img/may09/txt.gif" ><a class="tlink" href="latest%3Fformat=html.html" thref="/ep/pad/export/hacklab-piradiator/rev.%revision%?format=txt" >Pelkk teksti</a><br>
      <img src="http://www.kirjoitusalusta.fi/static/img/may09/doc.gif" ><a class="tlink" href="latest%3Fformat=html.html" thref="/ep/pad/export/hacklab-piradiator/rev.%revision%?format=doc" >Microsoft Word</a><br>
      <img src="http://www.kirjoitusalusta.fi/static/img/may09/pdf.gif" ><a class="tlink" href="latest%3Fformat=html.html" thref="/ep/pad/export/hacklab-piradiator/rev.%revision%?format=pdf" >PDF</a>
    </div>
    <div id="legend">
      <h2>Kirjoittajat</h2>
      <table id="authorstable" border="0" cellspacing="0" cellpadding="0">
      </table>
    </div>
  </div>
</div> 
    </div><!-- /padmain -->

  </div><!-- /padpage -->

  

 

  </body>
</html>
 