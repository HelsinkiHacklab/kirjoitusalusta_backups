<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-type"/>
  <meta content="en-us" http-equiv="Content-Language"/>
  <title>
   /hacklab-x-digi-jatko-harjoituksia
  </title>
 </head>
 <body>
  // main.v
  <br/>
  // Turpo CPU
  <br/>
  // - Spartan3-XC3S200-FT256-4
  <br/>
  // - Spartan6-XC6SLX45-CSG324-3
  <br/>
  <br/>
  `timescale 1ns / 1ps
  <br/>
  `default_nettype none
  <br/>
  <br/>
  //`define ADDI(rd, imm6) { 4'b0100, rd, imm6 }
  <br/>
  <br/>
  module main(
  <br/>
  input   wire                clk100MHz,
  <br/>
  input   wire    [7:0]       switch,
  <br/>
  output  reg     [7:0]       led
  <br/>
  );
  <br/>
  <br/>
  // Instruction opcodes
  <br/>
  parameter JMP_imm9            =     4'b0001;
  <br/>
  parameter MOVI_rd_imm6      =     4'b0010;
  <br/>
  parameter MOVX_rd_imm6      =     4'b0011;
  <br/>
  parameter ADDI_rd_imm6      =     4'b0100;
  <br/>
  parameter SAI_rd_imm6       =     4'b0101;
  <br/>
  parameter SLI_rd_imm6       =     4'b0110;
  <br/>
  parameter IN_rd_imm6        =     4'b0111;
  <br/>
  parameter OUT_rd_imm6       =     4'b1000;
  <br/>
  parameter ADD_rd_rs_rt      =     4'b1001;
  <br/>
  parameter SUB_rd_rs_rt      =     4'b1010;
  <br/>
  parameter AND_rd_rs_rt      =     4'b1011;
  <br/>
  parameter OR_rd_rs_rt       =     4'b1100;
  <br/>
  parameter XOR_rd_rs_rt      =     4'b1101;
  <br/>
  parameter MUL_rd_rs_rt      =     4'b1110;
  <br/>
  parameter UMUL_rd_rs_rt     =     4'b1111;
  <br/>
  parameter LD_rd_rs          =     7'b0000_001;
  <br/>
  parameter ST_rd_rs          =     7'b0000_010;
  <br/>
  parameter INCZ_rd_rs        =     7'b0000_011;
  <br/>
  parameter DECZ_rd_rs        =     7'b0000_100;
  <br/>
  parameter SKPLT_rd_rs       =     7'b0000_101;
  <br/>
  parameter SKPLE_rd_rs       =     7'b0000_110;
  <br/>
  parameter SKPEQ_rd_rs       =     7'b0000_111;
  <br/>
  parameter INC_rd            =    10'b0000_000_001;
  <br/>
  parameter DEC_rd            =    10'b0000_000_010;
  <br/>
  parameter NOT_rd            =    10'b0000_000_011;
  <br/>
  parameter NEG_rd            =    10'b0000_000_100;
  <br/>
  parameter ABS_rd            =    10'b0000_000_101;
  <br/>
  parameter SKPZ_rd           =    10'b0000_000_110;
  <br/>
  parameter SKPNZ_rd          =    10'b0000_000_111;
  <br/>
  parameter NOP               =    13'b0000_000_000_000;
  <br/>
  parameter _X4               =    13'b0000_000_000_001;
  <br/>
  parameter _X5               =    13'b0000_000_000_010;
  <br/>
  parameter _X6               =    13'b0000_000_000_011;
  <br/>
  parameter _X7               =    13'b0000_000_000_100;
  <br/>
  parameter _X8               =    13'b0000_000_000_101;
  <br/>
  parameter _X9               =    13'b0000_000_000_110;
  <br/>
  parameter HCF                =    13'b0000_000_000_111;
  <br/>
  <br/>
  // General purpose regisgters
  <br/>
  parameter R0 =                    3'h0;
  <br/>
  parameter R1 =                    3'h1;
  <br/>
  parameter R2 =                    3'h2;
  <br/>
  parameter R3 =                    3'h3;
  <br/>
  parameter R4 =                    3'h4;
  <br/>
  parameter R5 =                    3'h5;
  <br/>
  parameter R6 =                    3'h6;
  <br/>
  parameter R7 =                    3'h7;
  <br/>
  <br/>
  // Register file
  <br/>
  reg     [17:0]                     registers[7:0];
  <br/>
  <br/>
  // Program counter
  <br/>
  reg     [8:0]                     program_counter = 0;
  <br/>
  <br/>
  // Program memory
  <br/>
  reg        [12:0]                    program_memory[511:0];
  <br/>
  <br/>
  // Data memory
  <br/>
  reg        [17:0]                    data_memory[255:0];
  <br/>
  <br/>
  // Current instruction
  <br/>
  wire    [12:0]        instruction = program_memory[program_counter];
  <br/>
  //wire    [3:0]       opcode4 = instruction[12:9];
  <br/>
  //wire    [3:0]       opcode4 = instruction[12-:4];
  <br/>
  wire    [3:0]       opcode4 = instruction[12:9];
  <br/>
  wire    [2:0]       opcode4_rd = instruction[8:6];
  <br/>
  wire    [2:0]       opcode4_rs = instruction[5:3];
  <br/>
  wire    [2:0]       opcode4_rt = instruction[2:0];
  <br/>
  wire    [8:0]       opcode4_imm9 = instruction[8:0];
  <br/>
  wire    [5:0]       opcode4_imm6 = instruction[5:0];
  <br/>
  wire    [6:0]       opcode7 = instruction[12:6];
  <br/>
  wire    [2:0]       opcode7_rd = instruction[5:3];
  <br/>
  wire    [2:0]       opcode7_rs = instruction[2:0];
  <br/>
  wire    [9:0]       opcode10 = instruction[12:3];
  <br/>
  wire    [2:0]       opcode10_rd = instruction[2:0];
  <br/>
  wire    [12:0]      opcode13 = instruction[12:0];
  <br/>
  <br/>
  // Initialize data memory
  <br/>
  //reg     [63:0]    i;
  <br/>
  integer i;
  <br/>
  initial begin
  <br/>
  for (i = 0; i &lt; 256; i = i + 1) begin
  <br/>
  data_memory[i] = i;
  <br/>
  end
  <br/>
  data_memory[1] =     0;
  <br/>
  data_memory[2] =     100;
  <br/>
  data_memory[3] =     1;
  <br/>
  end
  <br/>
  <br/>
  initial begin
  <br/>
  led[7:0] = 8'b01010101;
  <br/>
  end
  <br/>
  <br/>
  // Initialize program memory
  <br/>
  initial begin
  <br/>
  for (i = 0; i &lt; 512; i = i + 1) begin
  <br/>
  program_memory[i] =     { NOP   };
  <br/>
  end
  <br/>
  <br/>
  program_memory[0] =     { MOVI_rd_imm6,     R0,     6'd0        };
  <br/>
  program_memory[1] =     { INC_rd,           R0      };
  <br/>
  program_memory[2] =     { OUT_rd_imm6,         R0,        6'd0    };
  <br/>
  program_memory[3] =     { JMP_imm9,         9'd1    };
  <br/>
  <br/>
  /*
  <br/>
  program_memory[0] =     { MOVI_rd_imm6,     R0,     6'd0        };
  <br/>
  program_memory[1] =     { MOVI_rd_imm6,     R1,     6'd0        };
  <br/>
  program_memory[2] =     { INC_rd,           R0      };
  <br/>
  program_memory[3] =     { INCZ_rd_rs,       R1, R0  };
  <br/>
  program_memory[4] =     { OUT_rd_imm6,         R1,        6'd0    };
  <br/>
  program_memory[5] =     { JMP_imm9,         9'd2    };
  <br/>
  */
  <br/>
  <br/>
  //program_memory[5] =     `ADDI(R6, 6'd0);
  <br/>
  <br/>
  //program_memory[3] =     { MOVI_rd_imm6,     R1,     6'd0        };
  <br/>
  //program_memory[4] =     { SKPLT_rd_rs,        R1, R2  };
  <br/>
  //program_memory[5] =     { JMP_imm9,         9'd100    };
  <br/>
  // {
  <br/>
  //program_memory[5] =     { NOP               };
  <br/>
  //program_memory[6] =     { NOP               };
  <br/>
  //program_memory[7] =     { NOP               };
  <br/>
  //program_memory[8] =     { NOP               };
  <br/>
  //program_memory[6] =     { INC_rd,           R1      };
  <br/>
  //program_memory[7] =     { JMP_imm9,         9'd4    };
  <br/>
  // }
  <br/>
  //program_memory[100] =     { INC_rd,             R7      };
  <br/>
  //program_memory[101] =     { OUT_rd_imm6,         R7,        6'd0    };
  <br/>
  //program_memory[102] =     { JMP_imm9,         9'd3    };
  <br/>
  <br/>
  /*
  <br/>
  program_memory[100] =     { IN_rd_imm6,         R7,        6'd0    };
  <br/>
  program_memory[101] =     { NOT_rd,           R7      };
  <br/>
  program_memory[102] =     { OUT_rd_imm6,         R7,        6'd0    };
  <br/>
  program_memory[103] =     { JMP_imm9,         9'd0    };
  <br/>
  */
  <br/>
  // Read switch and set leds, io[0] &lt;= io[0]
  <br/>
  /*
  <br/>
  <br/>
  program_memory[100] =     { IN_rd_imm6,         R7,        6'd0    };
  <br/>
  program_memory[101] =     { ADD_rd_rs_rt,     R7, R7, R7      };
  <br/>
  program_memory[102] =     { OUT_rd_imm6,         R7,        6'd0    };
  <br/>
  program_memory[103] =     { JMP_imm9,         9'd100    };
  <br/>
  */
  <br/>
  program_memory[511] =     { HCF               };
  <br/>
  end
  <br/>
  <br/>
  // PLL wires needed
  <br/>
  wire                                clk100MHz_bufg;
  <br/>
  reg     [28:0]                      clk_scaler = 0;
  <br/>
  reg                                 clkXHz_sel;
  <br/>
  wire                                 clkXHz_unbuf;
  <br/>
  wire                                clkXHz_bufg;
  <br/>
  <br/>
  // External clock distributed to global clock network
  <br/>
  IBUFG ibufg_xx1(
  <br/>
  .I(clk100MHz),
  <br/>
  .O(clk100MHz_bufg)
  <br/>
  );
  <br/>
  <br/>
  BUFGMUX bufgmux_xx1(
  <br/>
  .I0(1'b0),
  <br/>
  .I1(1'b1),
  <br/>
  .S(clkXHz_sel),
  <br/>
  .O(clkXHz_unbuf)
  <br/>
  );
  <br/>
  <br/>
  BUFG bufg_xx2(
  <br/>
  .I(clkXHz_unbuf),
  <br/>
  .O(clkXHz_bufg)
  <br/>
  );
  <br/>
  <br/>
  always @(posedge clk100MHz_bufg) begin
  <br/>
  if (clk_scaler == 28'd50_000_000) begin
  <br/>
  clk_scaler &lt;= 0;
  <br/>
  clkXHz_sel &lt;= ~clkXHz_sel;
  <br/>
  end else begin
  <br/>
  clk_scaler &lt;= clk_scaler + 1;
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  <br/>
  // Synchronous part of processor
  <br/>
  always @(posedge clkXHz_bufg) begin
  <br/>
  case(opcode4)
  <br/>
  JMP_imm9: begin
  <br/>
  program_counter &lt;= opcode4_imm9;
  <br/>
  end
  <br/>
  MOVI_rd_imm6: begin
  <br/>
  registers[opcode4_rd] &lt;= opcode4_imm6;
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  MOVX_rd_imm6: begin
  <br/>
  registers[opcode4_rd] &lt;= (registers[opcode4_rd] &lt;&lt; 6) | opcode4_imm6;
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  ADDI_rd_imm6: begin
  <br/>
  if (opcode4_imm6[5]) begin
  <br/>
  registers[opcode4_rd] &lt;= registers[opcode4_rd] - opcode4_imm6[4:0];
  <br/>
  end else begin
  <br/>
  registers[opcode4_rd] &lt;= registers[opcode4_rd] + opcode4_imm6[4:0] + 1;
  <br/>
  end
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  /*
  <br/>
  SAI_rd_imm6: begin
  <br/>
  if (opcode4_imm6[5]) begin
  <br/>
  18'b100000000_000000000
  <br/>
  wire signed [17:0] rd = registers[opcode4_rd];
  <br/>
  registers[opcode4_rd] &lt;=  rd &gt;&gt; opcode4_imm6[4:0];
  <br/>
  end else begin
  <br/>
  registers[opcode4_rd] &lt;= registers[opcode4_rd] &lt;&lt; (opcode4_imm6[4:0] + 1);
  <br/>
  end
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  */
  <br/>
  SLI_rd_imm6: begin
  <br/>
  if (opcode4_imm6[5]) begin
  <br/>
  registers[opcode4_rd] &lt;=  registers[opcode4_rd] &gt;&gt; opcode4_imm6[4:0];
  <br/>
  end else begin
  <br/>
  registers[opcode4_rd] &lt;= registers[opcode4_rd] &lt;&lt; (opcode4_imm6[4:0] + 1);
  <br/>
  end
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  IN_rd_imm6: begin
  <br/>
  registers[opcode4_rd] &lt;= switch[7:0];            // &lt;= io[opcode_imm6]
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  OUT_rd_imm6: begin
  <br/>
  led[7:0] &lt;= registers[opcode4_rd];  //[17:10];            // io[opcode_imm6] &lt;=
  <br/>
  //led[7:0] &lt;= registers[opcode4_rd][17:10];
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  ADD_rd_rs_rt: begin
  <br/>
  registers[opcode4_rd] &lt;= registers[opcode4_rs] + registers[opcode4_rt];
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  SUB_rd_rs_rt: begin
  <br/>
  registers[opcode4_rd] &lt;= registers[opcode4_rs] - registers[opcode4_rt];
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  AND_rd_rs_rt: begin
  <br/>
  registers[opcode4_rd] &lt;= registers[opcode4_rs] &amp; registers[opcode4_rt];
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  OR_rd_rs_rt: begin
  <br/>
  registers[opcode4_rd] &lt;= registers[opcode4_rs] | registers[opcode4_rt];
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  XOR_rd_rs_rt: begin
  <br/>
  registers[opcode4_rd] &lt;= registers[opcode4_rs] ^ registers[opcode4_rt];
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  /*
  <br/>
  MUL_rd_rs_rt: begin
  <br/>
  registers[opcode4_rd] &lt;= registers[opcode4_rs] * registers[opcode4_rt];
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  */
  <br/>
  UMUL_rd_rs_rt: begin
  <br/>
  registers[opcode4_rd] &lt;= registers[opcode4_rs] * registers[opcode4_rt];
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  default: begin
  <br/>
  case(opcode7)
  <br/>
  LD_rd_rs: begin
  <br/>
  registers[opcode7_rd] &lt;= data_memory[registers[opcode7_rs]];
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  ST_rd_rs: begin
  <br/>
  data_memory[registers[opcode7_rs]] &lt;= registers[opcode7_rd];
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  INCZ_rd_rs: begin
  <br/>
  registers[opcode7_rd] &lt;= registers[opcode7_rd] + ((registers[opcode7_rs] == 0) ? 1 : 0);
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  DECZ_rd_rs: begin
  <br/>
  registers[opcode7_rd] &lt;= registers[opcode7_rd] - ((registers[opcode7_rs] == 0) ? 1 : 0);
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  SKPLT_rd_rs: begin
  <br/>
  program_counter &lt;= program_counter + (registers[opcode7_rd] &lt; registers[opcode7_rd]) ? 2 : 1;
  <br/>
  end
  <br/>
  SKPLE_rd_rs: begin
  <br/>
  program_counter &lt;= program_counter + (registers[opcode7_rd] &lt;= registers[opcode7_rd]) ? 2 : 1;
  <br/>
  end
  <br/>
  SKPEQ_rd_rs: begin
  <br/>
  program_counter &lt;= program_counter + (registers[opcode7_rd] == registers[opcode7_rd]) ? 2 : 1;
  <br/>
  end
  <br/>
  default: begin
  <br/>
  case(opcode10)
  <br/>
  INC_rd: begin
  <br/>
  registers[opcode10_rd] &lt;= registers[opcode10_rd] + 1;
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  DEC_rd: begin
  <br/>
  registers[opcode10_rd] &lt;= registers[opcode10_rd] - 1;
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  NOT_rd: begin
  <br/>
  registers[opcode10_rd] &lt;= ~registers[opcode10_rd];
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  NEG_rd: begin
  <br/>
  registers[opcode10_rd] &lt;= -registers[opcode10_rd];
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  ABS_rd: begin
  <br/>
  registers[opcode10_rd] &lt;= (registers[opcode10_rd] &lt; 0) ? -registers[opcode10_rd] : registers[opcode10_rd];
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  SKPZ_rd: begin
  <br/>
  program_counter &lt;= program_counter + (registers[opcode7_rd] == 0) ? 2 : 1;
  <br/>
  end
  <br/>
  SKPNZ_rd: begin
  <br/>
  program_counter &lt;= program_counter + (registers[opcode7_rd] != 0) ? 2 : 1;
  <br/>
  end
  <br/>
  default: begin
  <br/>
  case(opcode13)
  <br/>
  NOP: begin
  <br/>
  program_counter &lt;= program_counter + 1;
  <br/>
  end
  <br/>
  HCF: begin
  <br/>
  program_counter &lt;= program_counter;
  <br/>
  end
  <br/>
  endcase
  <br/>
  end
  <br/>
  endcase
  <br/>
  end
  <br/>
  endcase
  <br/>
  end
  <br/>
  endcase
  <br/>
  end
  <br/>
  <br/>
  endmodule
  <br/>
  <br/>
 </body>
</html>