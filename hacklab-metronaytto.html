<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="en-us" />
<title>/hacklab-metronaytto</title>
</head>
<body><b><u>Metronäyttö</u></b><br
/><br
/><b>Kuvia:</b><br
/><ul><li><a href="https://www.dropbox.com/sh/ia7ofm5d4jm92lp/vyNNTau_SD">https://www.dropbox.com/sh/ia7ofm5d4jm92lp/vyNNTau_SD</a><br/><br
/></li></ul
><b>Videoita:</b><br
/><ul><li><a href="http://www.youtube.com/watch?v=HZdKBqu0UWA">http://www.youtube.com/watch?v=HZdKBqu0UWA</a><br/><br
/></li></ul
><b>Infoa:</b><br
/><ul><li><a href="http://sooda.dy.fi/tag/metrolaiturinäytöt/">http://sooda.dy.fi/tag/metrolaiturinäytöt/</a><br/><br
/></li></ul
><b>Lokia:</b><br
/><ul><li>2013-01-10 Raahattiin kolossi labille ihmeteltiin</li
><li>2013-02-14 Purettiin paksusähköpiuhat ja kuristimet</li
><li>2013-02-28 Setvittiin protokollaa</li
><li>2013-03-14 'Hacklab' näytöllä!<ul><li><a href="https://www.dropbox.com/s/9qg1ru46afl0pw1/Hacklab2.jpg">https://www.dropbox.com/s/9qg1ru46afl0pw1/Hacklab2.jpg</a></li
><li>fonttien renderöinnissä on jotain <b>todella </b>älykästä logiikkaa, se valitsee kirjainten fontin siten, että kirjaimet eivät osu näyttöjen väleihin:</li
><li><a href="http://www.youtube.com/watch?v=HZdKBqu0UWA">http://www.youtube.com/watch?v=HZdKBqu0UWA</a></li
><li>Scroller-koodi, joka näkyy Youtube-videossa, pohjana soodan disassembly:<ul><li><a href="https://dl.dropbox.com/u/39562463/eprom3.asm">https://dl.dropbox.com/u/39562463/eprom3.asm</a><br/><br
/></li></ul
></li></ul
></li></ul
>Tämä voitaisin kirjoittaa puhtaaksi yhdessä jossain välissä:<br
/><br
/><b>Reverse engineering:&nbsp;</b><br
/><br
/>Kaikenlaista noista soodan keräämistä tiedoistakin irtoaa. Tällaisia päätelmiä ja arvauksia hardwaresta, näitä voisi todistella oikeiksi tai vääriksi todellisen hw:n äärellä:<br
/><br
/>Kortilla ei ole muuta EEPROMia kuin 28C64, nuo pienet piirit ovat TTL-PROMmeja (kertaohjelmoitava fuse-PROM). Isompi PROM näköjään sisältää oletustekstit. Pienempi tekee osoitteen dekoodauksen.<br
/><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Muistiavaruuden osoitekartta:<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000H...7FFFH -&gt; EPROM&nbsp; (32 kB)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8000H...BFFFH -&gt; RAM&nbsp;&nbsp;&nbsp; (blokki 16 kB, piiri 8 kB)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C000H...DFFFH -&gt; EEPROM (8 kB)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E000H...FFFFH -&gt; kalustamaton paikka (8 kB)<br
/><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I/O-avaruus on dekoodattu HCT138:lla. Piirien osoitteet ja ohjelman tekemät asetukset:<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10H...1FH = UART 1<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10H = data<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11H = control&nbsp; (7-E-1, 16x baud, RTS on, RXEN, TXEN)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Skoopilla mitaten tämä on 600 baud<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Menee modeemille, joka on toisella kortilla<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20H...2FH = UART 2<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20H = data<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 21H = control (8-N-1, 16x baud, RTS on, RXEN, TXEN)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9600 baudilla näkyy pc:llä juttuja<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30H...3FH = 8255<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30H = PA<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31H = PB<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32H = PC<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 33H = mode (PA out, PB out, PC in)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 40H...4FH = 8155<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 40H = mode (PA in, PB out, PC out)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 41H = PA<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 42H = PB<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 43H = PC<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 44H = timer hi<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 45H = timer lo<br
/><br
/>8155:n PB ja PC hoitavat ilmeisesti näytöille lähtevää väylää. Ohjelmassa on useita pieniä funktioita, joilla voi pulssittaa yksittäisiä C-portin bittejä, lähettää annetun datan sarjamuodossa bitti kerrallaan + strobe -tyylillä jostain portin bitistä ulos, heittää PB-portista one-hot-tyyppisiä valintoja ulos jne. Vaatii tarkempaa kaivelua, mikä 8155:n pinni menee mihinkäkin väylällä.<br
/><br
/>UARTtien baudinopeus pitää mitata. Tehdään mahdollisesti 8155:n timerillä + jakajilla, voi tulla suoraan 8085:n systeemikellostakin hard-wired, koska jakajia on riittävästi (4020 = 14-stage).<br
/>- Luultavasti ei 8155:ltä, koska koodi resetoi laskurin arvon vakioksi tietyin välein.<br
/><br
/>t. jari<br
/><br
/>Toiselta PCB:ltä mielenkiintoisinta on MC14412 - "Universal Low Speed Modem (0-600 bps)" sekä UART-jännitetasomuuntimet. LTG-portti menee tälle piirilevylle, ja se oli ainoa näytön kontrolliboksin ulkopuolelle mennyt piuha, joten aikamoisella varmuudella tuo modeemi on yhteydessä UART1:een. Etupaneelin testpointeilla pitäisi päästä tuohon UART:iin kiinni suoraan.<br
/><br
/>Koodissa luetaan useasti turhaan 11h-porttia, siihen lienee yhdistettynä<br
/>jokin watchdog-toiminnallisuus?<br
/><br
/>Tämä herättää ihmetystä, ei pitäisi olla tuollaista ominaisuutta 8251:ssä, eikä muutenkaan vaadi jatkuvaa pollausta.Tuo portti on UART1:n status-tavu.<br
/><br
/>- Jep, muuta järjellistä en tuolle keksinyt. Ehkä ajamalla tuo WD-test selviää mitä tapahtuu<br
/>(sen testin lopussa on ikuinen luuppi).<br
/>- WD-test sisältää muutakin debugprintiä (mm. taikanumeroita ja fontin nimen, sekä lopuksi piirtää koko näytön täyteen mustaa), ja looppaa loputtuaan taas alusta (ainakin toisen kerran, en katsonut pidempään) -sooda<br
/>- =&gt; siellä ihan oikeasti on jossain joku watchdog-viritys<br
/><br
/>4020 on ainut sen tyyppinen piiri, josta voisi saada WD:n. Arvaus: UART1:n chip select on viety 4020:n resettiin, ja jos 4020 pääsee laskemaan tarpeeksi pitkälle, se resetoi prosessorin. -- Ei toimi, 4020:n reset on ylhäällä aktiivinen, ja kortilla ei ole inverttereitä.<br
/><br
/>Joku viritys siellä on, joka vaatii UART1:n statuksen lukemista vähän väliä (IN 11H). Ilman tätä tulee noutaja.<br
/><br
/><br
/>8155 PA (portti 41h) on mapattu DIP-switcheihin. Niillä on seuraava funktio:<br
/>&nbsp;&nbsp;&nbsp; bit 7 -&nbsp;&nbsp; testitila. Pitäisi tulostaa joka segmenttiin jotain kamaa, sekä lopuksi<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WD-test eli watchdog test.<br
/>&nbsp;&nbsp;&nbsp; bit 4-6 - laitteen ID johon se reagoi UART1-väylällä<br
/>&nbsp;&nbsp;&nbsp; bit 1-3 - lisää ID-bittejä<br
/>&nbsp;&nbsp;&nbsp; bit 0 - poistaa käytöstä XOR-checksummin UART1-komentojen yhteydessä<br
/><br
/>Konsta taisi sanoa saaneensa 9600 baudilla dataa ulos RX/TX merkityillä pinneistä ("@I.@E-.@E+.@E+.@E+."), ja softa printtaileekin juuri tuommoista dataa UART2:een.<br
/>Mitään tuon ihmeempää ei UART2:sta sitten saakkaan, kaikki oikea info menee UART1:n päällä. Kuten ylempänä, UART1:n konffi ei ole se tavanomaisin, vaan 7 data-bittiä, 1 stop-bitti, ja even parity. Baudrate lienee sama.<br
/><br
/>Ok, hieman yksityiskohtaisemmin, UART2:lla voi tehdä kaksi asiaa.<br
/>- Bootissa tulee viesti "SPA-test N",<br
/>&nbsp;&nbsp;&nbsp; missä N laskee kakkosesta nollaan. Heittämällä rivinvaihdon 0xC UART2:een<br
/>&nbsp;&nbsp;&nbsp; tuon testin saa keskeytettyä ja jatkettua boottia.<br
/>-&nbsp;&nbsp; E-komennon yhteydessä (alempana selitetty) saa UART2:een jonkun muuttujan<br
/>&nbsp;&nbsp;&nbsp; tulosteen, jos sieltä löytyy tavu ':'.<br
/><br
/>UART1:n kommunikaatio on hyvin pitkälle ASCII-pohjaista. Eli esim. boolean-arvot kulkee väylällä ASCII-'0' ja ASCII-'1':nä, kuten kaikki muutkin lukuarvot.<br
/><br
/>UART1:stä luvussa on kolme vaihetta:<br
/>&nbsp;&nbsp;&nbsp; - osoitettavan laitteen valinta<br
/>&nbsp;&nbsp;&nbsp; - komentopuskurin lataus (0x2)<br
/>&nbsp;&nbsp;&nbsp; - komennon suoritus (0x4)<br
/><br
/>Osoite muodostuu seuraavasti:<br
/>&nbsp;&nbsp;&nbsp; - laitteen ID ASCII-numerona, eli '0'-'7'. Tämä tulee DIP-switchin biteistä 4-6<br
/>&nbsp;&nbsp;&nbsp; - toinen ID ASCIIna (DIPin biteistä 1-3) LSL 1. Alin bitti kertoo nyt luetaanko(0) vaiko kirjoitetaanko (1) näytöltä/näytölle<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - esim. jos DIP[1:3] = '001' ja halutaan kirjoittaa näytölle, niin 2. tavuksi halutaan '3'<br
/>&nbsp;&nbsp;&nbsp; - ASCII ENQ (0x5) päättää osoitevaiheen<br
/><br
/>Kirjoitustilassa laite jää odottelemaan ASCII STXää (0x2), jonka jälkeen luetaan komentoja terminoituna ASCII ETX:llä (0x3) sekä checksum-tavu.<br
/>Checksum on yksinkertainen XOR komentotavuista.<br
/>(ETX lasketaan checksummiin, STX ei, TOISIN KUIN ENNEN MAINITSIN)<br
/>Tämän checksum-tarkastuksen saa dip-switchin nollabitillä pois.<br
/><br
/>Komentopuskurin tavu #8 kertoo mitä tapahtuu:<br
/><br
/>'E':<br
/>&nbsp;&nbsp;&nbsp; Valitsee mitä ruudulla näkyy, sisältö tulee 8kb EEPROMista<br
/><br
/>&nbsp;&nbsp;&nbsp; Data bytes have the following meaning:<br
/>&nbsp;&nbsp;&nbsp; #00: constant 0x2, the command byte<br
/>&nbsp;&nbsp;&nbsp; #01: unknown, NOT A STRING VALUE AS WAS MENTIONED BEFORE!<br
/>&nbsp;&nbsp;&nbsp; #02: unknown value related to clock+blinker. Compared to '0' and '1'.<br
/>&nbsp;&nbsp;&nbsp; #03-#05 expected version number of the string ROM. If incorrect,<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error code '3' is set.<br
/>&nbsp;&nbsp;&nbsp; ...<br
/>&nbsp;&nbsp;&nbsp; #08: constant 'E', the command byte<br
/>&nbsp;&nbsp;&nbsp; #09: Tenths digit of the minutes to train ETA (ASCII)<br
/>&nbsp;&nbsp;&nbsp; #0a: Ones digit of the minutes to train ETA (ASCII)<br
/>&nbsp;&nbsp;&nbsp; #0b: Unknown, not used?<br
/>&nbsp;&nbsp;&nbsp; #0c: Animation frame of the blinker (ASCII number), 0 = empty<br
/>&nbsp;&nbsp;&nbsp; #0d: HiByte of the first (finnish) text line's key.<br
/>&nbsp;&nbsp;&nbsp; #0e: LoByte of the first (finnish) text line's key.<br
/>&nbsp;&nbsp;&nbsp; #0f: HiByte of the second (swedish) text line's key.<br
/>&nbsp;&nbsp;&nbsp; #10: LoByte of the second (swedish) text line's key.<br
/>&nbsp;&nbsp;&nbsp; #11: Generate a debug message (@E+.) to UART2 if not '0'.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Then, if UART2 contains ':', print some more (unknown) data to UART2<br
/><br
/>'D':<br
/>&nbsp;&nbsp;&nbsp; This subcommand can modify the String EEPROM.<br
/>&nbsp;&nbsp;&nbsp; Data bytes:<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - If bytes #01, #02, #06, #07 are all '0',<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all String EEPROM data WILL BE ERASED after the execute command (4)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Otherwise, a new key-value pair is appended to the string EEPROM.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bytes #01, #02, #06, #07 contain the four-byte key.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; All the bytes at #09 are copied as the String value,<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terminated by the ASCII ETX (3) that also ended the command buffer!.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Then the ROM version is set to bytes #3-#5 and the version<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is checksummed. (See below for definition of ROM version)<br
/><br
/>'T':<br
/>&nbsp;&nbsp;&nbsp; This prints a string!!<br
/>&nbsp;&nbsp;&nbsp; Data bytes:<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #00: 0x2, the STX<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #01-#02: Segment parameter! (See later for definition)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #06: Some display param? Checks for one of "sbn".<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #07: Positioning? Checks for one of "lrmz".<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #08: The command byte 'T'.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #09: The string! Terminated by ASCII ETX (0x3), which also<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ended the command buffer!<br
/><br
/>'N':<br
/>&nbsp;&nbsp;&nbsp; Clears the screen?<br
/>&nbsp;&nbsp;&nbsp; Data bytes:<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #01-#02: Segment parameter.<br
/><br
/>Komentopuskurin antamisen jälkeen komento suoritetaan kirjoittamalla ASCII EOT (0x4).<br
/>EOT:n kirjoittaminen väylälle palauttaa näytön aina alkutilaan (eli odottamaan näytön osoitetta). Samaten jonkinnäköinen timeout siellä on.<br
/><br
/>Komentopuskurin luonti ja sen suoritus on erikseen luultavasti siksi, että jotkut operaatiot voivat asettaa virhekoodin komentopuskurin antovaiheessa (esim jos EEPROMilta loppuu tila D-komennon yhteydessä).<br
/><br
/>Virhekoodin saa luettua sanomalla osoitevaiheessa (tokan tavun lsb = 0), mutta vastauksen&nbsp; rakenne riippuu siitä, mikä komento aktivoitiin viimeisessä komentopuskurissa. Valitsemalla lukuoperaation pitäisi UART1:een tulla tulostetta, ja samalla päätyy johonkin moodiin, jossa<br
/>&nbsp;komentotavut on eroteltu 0x10- ja 0x31-tavuilla (vastaavasti kuin kirjoitustilassa komentotavut erottaa STX ja ETX). Nähdäkseni tuossa koodissa on kuitenkin bugi (ehdollisissa hypyissä pari ehtoa väärinpäin), eikä kyseeisessä moodissa voi tehdä mitään hyödyllistä.<br
/><br
/>Komennon antaminen muuttaa myös softan sisäistä tilaa siinä mielessä, että&nbsp;<br
/>E-komennon antamisen jälkeen laite osaa itse vilkuttaa sekunttivilkutinta ja päivittää minuuttilaskuria. Tämä feature menee pois päältä T-komennon annettaessa.<br
/>Näyttänee tosin myös siltä, että jos UART1:ssä ei liiku dataa hetkeen, resetoituu<br
/>laite näyttämään Ruoholahtea jonkin ajan (3 minuuttia?) päästä.<br
/><br
/>Eli esimerkkikirjoituskomento (lista tavuja)<br
/>&nbsp;&nbsp;&nbsp; [DIP[4:6] | '0', (DIP[1:3] &lt;&lt; 1) | 1 | '0', ENQ, STX, segmentHi, segmentLo, ?, ?, ?, ?, ?, 'N', ETX, checksum, EOT]<br
/>&nbsp;&nbsp;&nbsp; ? = (lähes) mielivaltainen tavu, vaikkapa 'a' on turvallinen<br
/><br
/>Esimerkkilukukomento:<br
/>&nbsp;&nbsp;&nbsp; [DIP[4:6] | '0', (DIP[1:3] &lt;&lt; 1) | '0', ENQ]<br
/>&nbsp;&nbsp;&nbsp; Tällä pitäisi siis jotain tulostua. Kannattaa odotella hetki ennen uusien komentojen laittamista jos tätä yrittää.<br
/><br
/>LCD segment parameter:<br
/>&nbsp;&nbsp;&nbsp; The PrintString takes in HL a word describing which segment to fill. Values used are:<br
/>&nbsp;&nbsp;&nbsp; (Also, the N and T commands)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 0x101 for the finnish text<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 0x201 for the swedish text<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 0x301 for the clock?<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 0x302 for the blinking thingy? NOT SURE<br
/><br
/>Ohjelmakoodi on kaksiosainen: itse LCD:lle kommunikaatio on kirjoitettu C:llä, alkaa osoitteesta 0x4000, ja koko muu hela hoito on assembleria, alkaa 0x0:sta.<br
/>Tuo C-osuus on niin hirveää luettavaa, etten ole siihen perehtynyt.<br
/>Tuon assembler-osuuden sen sijaan selvittänyt koodin osalta melkeinpä perinpohjaisesti,<br
/>muuttujia en ihan niin paljoa.<br
/><br
/>Tietääkseni 8085:lle ei ollut mitään asiallista (tai asiatontakaan) C-kääntäjää tarjolla vuonna 90, veikkaan PL/M:ää. Korkean tason kielestä käännettyä kuitenkin.<br
/><br
/>Merkkijono-EEPROMin formaatti<br
/><br
/>#00:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seuraavan kuuden tavun XOR-checksum. Jos ei mätsää,<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; koko EEPROM tyhjennetään 'e':ksi.<br
/>#01-03:&nbsp;&nbsp;&nbsp; Merkkijono-EEPROMin versionumero, ASCII-numeroita.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E-komento vertaa komentopuskurissa annettua versionumeroa,<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ja antaa virheen jos nämä eivät ole samat. D-komennolla<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EEPROMin versionumero voidaan asettaa kirjoituksen yhteydessä.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Dumpatulta teksti-EEPROMilta löytyy muistaakseni '004')<br
/>#04-05:&nbsp;&nbsp;&nbsp; Osoitin seuraavaan vapaaseen tavuun EEPROMille. Tähän kohtaan D-komento<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; appendaa lisättävän avain-arvoparin.<br
/>...#0f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Taikanumero 'MHELS\x17'.<br
/>#10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x2, aloittaa merkkijonolistan<br
/>#11..&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n kpl avain-merkkijono-pareja eroteltuna 0x2:lla. Avain on aina 4 ASCII-tavua,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esim 1B01, ja tuota muotoa. 1Bxx on ekan rivin avain ja 2Bxx tokan rivin.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Listan päättää erotin 0x2. Loput on oletuksena täytetty 'e'-merkillä.<br
/>#1ffe-#1fff: Taikanumerot 0x17. Nämä ilmaisevat merkkijononkopiointirutiineille<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROM:n loppumisen. Samaan tapaan MHELS-signaturen 0x17<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kertoo ROM:n toisen pään, sillä hakurutiini tekee läpikäynnin lopusta alkuun.<br
/><br
/>Jonkinnäköinen fonttitaulukko löytyy offsetista 0x6800, 24 tavua/merkki.<br
/>Sekunttivilkuttimen merkit ovat muuten 0xb5-0xb8<br
/><br
/>Disclaimer, ylläoleva on *puhtaasti* disassembloimalla saatua tietoa, ihme jos tuolla ei jotain virheitä ole. Assembly-puolen koodista vapaasti saa kysellä, varmaan ehdin vastatakin joskus.<br
/><br
/>-Dezgeg (Tuomas)<br
/><br
/><br
/>--------------------------------------------------------<br
/><br
/>14.3. session tuloksia<br
/><br
/>EPROMin disassembly käännettiin netistä löytyneellä 8085-assemblerilla. Muutaman korjailun jälkeen (myös kääntäjä itse vaati korjailua) kääntäjän tuottama intel-hex on identtinen alkuperäisen EPROMista luetun kanssa.<br
/><br
/>Ohjaimen piirilevyllä oleva EPROM korvattiin Romulaattorilla (ROM-emulaattori) johon ladattiin kääntäjän tuotos. Näyttö jatkoi toimintaansa samoin kun ennenkin, eli siis toimii Romulaattorin kanssa.&nbsp;<br
/><br
/>Koodia muokkaamalla saatiin näytölle ensin omia kiinteitä tekstejä. Seuraavaksi tehtiin yksinkertainen skrolleri, josta on alussa linkitetty video. Lopuksi muokattu koodi ohjelmoitiin EPROMiin.<br
/><br
/>Havaintoja ohjelmasta:<br
/><br
/><ul><li>Osoitteesta 4000H alkava funktio kirjoittaa tekstin näytölle. Parametrit:<ul><li>&nbsp;&nbsp;&nbsp; DE = pointteri tekstiin, asciiz</li
><li>&nbsp;&nbsp;&nbsp; H = tekstin sijainti näytöllä<ul><li>01 = ylärivi</li
><li>02 = alarivi</li
><li>03 = näytön oikea laita (aikanäytön alue)</li></ul
></li
><li>&nbsp;&nbsp;&nbsp; L = kummalla puolella näyttöä teksti on (ei varmistettu, kun toinen puoli pöytää vasten :P)<br/><br
/></li></ul
></li
><li>Osoitteesta 00A0H alkava funktio on viivelooppi, viiveen pituus BC:ssä. Videossa näkyvä skrollerin askelten väliaika on saatu arvolla BC = 07FFH.<br/><br
/></li
><li>IN 11H käskyä pitää viljellä koodissa, muuten laukeaa vahtikoira.<br/><br
/></li
><li>Videossa näkyvä fonttien villi leveneminen ja kapeneminen on näytön omaa logiikkaa, kun se pyrkii optimoimaan tekstiä siten, että näyttöpaneelien välipalkki osuu aina kirjainten väliin ja kirjainten välit ovat muuten tasaiset.<br/><br
/></li></ul
>-- jari<br
/><br
/><br
/><br
/></body>
</html>
