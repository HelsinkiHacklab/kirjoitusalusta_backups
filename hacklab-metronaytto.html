<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="en-us" />
<title>/hacklab-metronaytto</title>
</head>
<body><b><u>Metronäyttö</u></b><br
/><br
/><b>Kuvia:</b><br
/><ul><li><a href="https://www.dropbox.com/sh/ia7ofm5d4jm92lp/vyNNTau_SD">https://www.dropbox.com/sh/ia7ofm5d4jm92lp/vyNNTau_SD</a><br/><br
/></li></ul
><b>Videoita:</b><br
/><ul><li><a href="http://www.youtube.com/watch?v=HZdKBqu0UWA">http://www.youtube.com/watch?v=HZdKBqu0UWA</a></li
><li><a href="http://www.youtube.com/watch?v=Wn1OTIk8cpw">http://www.youtube.com/watch?v=Wn1OTIk8cpw</a><br/><br
/></li></ul
><b>Infoa:</b><br
/><ul><li><a href="http://sooda.dy.fi/tag/metrolaiturinäytöt/">http://sooda.dy.fi/tag/metrolaiturinäytöt/</a></li
><li><a href="https://github.com/sooda/metro_station_display">https://github.com/sooda/metro_station_display</a></li
><li>soodan disasm: <a href="http://sooda.dy.fi/2013/2/23/metrolaiturinayttojen-softa/files/program.lst">http://sooda.dy.fi/2013/2/23/metrolaiturinayttojen-softa/files/program.lst</a></li
><li>kontrolleriboksin powerimoduuli PCM15E-1: <a href="http://www.cosel.co.jp/en/products/pdf/SFE_PMC.pdf">http://www.cosel.co.jp/en/products/pdf/SFE_PMC.pdf</a><br/><br
/></li></ul
><b>Lokia:</b><br
/><ul><li>2013-01-10 Raahattiin kolossi labille ihmeteltiin</li
><li>2013-02-14 Purettiin paksusähköpiuhat ja kuristimet</li
><li>2013-02-28 Setvittiin protokollaa</li
><li>2013-03-14 'Hacklab' näytöllä!<ul><li><a href="https://www.dropbox.com/s/9qg1ru46afl0pw1/Hacklab2.jpg">https://www.dropbox.com/s/9qg1ru46afl0pw1/Hacklab2.jpg</a></li
><li>fonttien renderöinnissä on jotain <b>todella </b>älykästä logiikkaa, se valitsee kirjainten fontin siten, että kirjaimet eivät osu näyttöjen väleihin:</li
><li><a href="http://www.youtube.com/watch?v=HZdKBqu0UWA">http://www.youtube.com/watch?v=HZdKBqu0UWA</a></li
><li>Scroller-koodi, joka näkyy Youtube-videossa, pohjana soodan disassembly:<ul><li><a href="https://dropbox.com/u/39562463/eprom3.asm">https://dropbox.com/u/39562463/eprom3.asm</a></li></ul
></li></ul
></li
><li>2013-03-28 matkittiin modeemia ja saatiin alkuperäistyyliin tekstiä näytölle. Huomattiin, että eeprom-piiri oli resetoitunut tyhjäksi, ja korvattiin se epromilla, johon kirjoitettiin alkuperäinen data. Tekstiä saa ladattua eepromilta, jolloin mukaan tulee kellonaika (joka laskee itsestään alaspäin) ja junavaunugrafiikka, sekä sitä voi syöttää suoraan. Modeemille menevän rs232:n saa suoraan kiinni pc:n sarjaporttiin, 600 baud 7E1. Yhteys on jotenkin epäluotettava, kun joka kerta komennot eivät mene läpi.</li
><li>2013-04-04 lcd-protokolla selvillä; väylälle omaa dataa teensyltä, alkuperäiseltä kortilta edelleen käyttikset ja 75 hertsin virkistys (?). doksit: <a href="https://github.com/sooda/metro_station_display">https://github.com/sooda/metro_station_display</a> helpointa nypätä i/o-piiri pois ja kytkeä teensyn johdot siihen.<br/><br
/></li></ul
><b>Disasm flowchart, ISO, 5355x7578 px:</b><br
/><ul><li><a href="https://www.dropbox.com/s/85473gzgx2iryui/metro_flowchart.png">https://www.dropbox.com/s/85473gzgx2iryui/metro_flowchart.png</a><ul><li>Download -&gt; omalle koneelle, muuten dropboxi skaalaa pienemmäksi<br/><br
/></li></ul
></li></ul
><b>Emulaattorilla kaapatut IO-porttitapahtumat (Dezgeg 29.03):</b><br
/><ul><li>Emulaattorina Win85: <a href="http://pythagoras.physics.upatras.gr/~gmanol/">http://pythagoras.physics.upatras.gr/~gmanol/</a><ul><li>8085-systeemeissä ilmeisesti kaikissa jokseenkin sama memory map (ts. ROM ja reset-vektori alhaalla), niin toimii ihan hyvin</li
><li>Tukee mielivaltaisia io-laitteita, toteutettuna Windowsin .dll-tiedostoina</li
><li>DLL-api reverse-engineerattu, ja kehitelty io-tapahtumat tiedostoon tulostava plugin</li></ul
></li
><li>Kaappaukset: <a href="http://www.cs.helsinki.fi/u/tmtynkky/boot-io-traces/">http://www.cs.helsinki.fi/u/tmtynkky/boot-io-traces/</a><ul><li>Numeroiduissa tiedostoissa on io-tapahtumat resetistä ULAM-HOG-tekstin tulostamisen loppuun asti, jaoteltuna kolmeen tiedostoon<ul><li>UARTtien ym. alustus, näytön tyhjennys, ja itse tekstin printtaus</li
><li>Lisäksi kaapattu "Test: SPA n" arvoilla n = 0,1,2, sekä WD-testin kaikki segmentit täyttävä tulostus</li></ul
></li
><li>Laitteille ei ole mitään emulointia (read palauttaa aina nollan), niin tietenkään kaikki ei ihan vastaa oikeaa. Mutta toivottavasti edes tuosta saa purettua jotain.<br/><br
/></li></ul
></li></ul
><b>LCD-väylän formaatti:</b><br
/>Emulaattorin tulosteesta sai reverse-engineerattua väyläformaatin.<br
/>Sanomalla esim. sort -u 3-ulam-hog.txt | grep 'out' saa kaikki ohjelmassa käytetyt PC-portti-arvo-kolmikot, joissa on tapahtunut IO-kirjoitus. Tuosta voi sitten päätellä esim. että ohjelman kohdassa PC = 4036 on kirjoitettu porttiin vaan ykkösbittiä. Tuolla tavoin saa filtteröityä pois kaikki ei-databittikirjoitukset.<br
/><br
/>Databitit saa siis eristettyä sanomalla "cat 3-ulam-hog.txt | egrep '408a|409b|40b4|40c5'".<br
/>Yhteen normi-riviin (eli vaikkapa bootin ULAM-HOG) menee 2208 = 4 * 24 * 23 bittiä.<br
/>Yhdessä paneelissahan on siis 24 saraketta, sarakkeessa 23 erimuotoista kolmiopikseliä, ja normirivillähän on se 4 paneelia. Kuvasta <a href="http://www.cs.helsinki.fi/u/tmtynkky/boot-io-traces/bittijarjestys.jpg">http://www.cs.helsinki.fi/u/tmtynkky/boot-io-traces/bittijarjestys.jpg</a> ilmenee pikseleiden muodot, joskaan suhteet eivät ole ihan oikein.<br
/><br
/>Ohjausta varten on jokainen sarake jaettu keskeltä kahtia, joten bittivirta on seuraavanlainen:<br
/>&nbsp; 1. oikealta vasemmalle jokaisen sarakkeen (5 * 24) 12 ylintä pikseliä<br
/>&nbsp; 2. vasemmalta oikealle jokaisen sarakkeen (5 * 24) 11 alinta pikseliä<br
/>&nbsp; Edellä mainitussa kuvassa on numeroitu mikä bitti vastaa mitäkin pikseliä sarakkeessa.<br
/>&nbsp;&nbsp;<br
/>&nbsp; <a href="http://www.cs.helsinki.fi/u/tmtynkky/boot-io-traces/printline_decoder.py">http://www.cs.helsinki.fi/u/tmtynkky/boot-io-traces/printline_decoder.py</a> on ohjelma,<br
/>&nbsp; jolla voi dekoodata bittivirran kuvaksi. Sieltä voi myös viime kädessä lukea miten tuo&nbsp;<br
/>&nbsp; formaatti menee, mikäli selityksestä ei saanut selvää :). Screenshot:<br
/>&nbsp; <a href="http://www.cs.helsinki.fi/u/tmtynkky/boot-io-traces/screeshot.png">http://www.cs.helsinki.fi/u/tmtynkky/boot-io-traces/screeshot.png</a><br
/>&nbsp; Vaatii pygamen, ohjeet kommenteissa.&nbsp;<br
/><br
/><b>Fonttidata:</b><br
/>Yleisesti fontista: merkin maksimileveys on 5 saraketta.<br
/>Jokaisesta merkistä voi olla useita erileveyksisiä variantteja.<br
/>Piirtokoodi valitsee fontista sellaiset variaatiot sekä merkkien välisen tyhjän tilan,<br
/>että teksti mahtuu näytölle mahdollisimman kauniisti.<br
/>Videosta <a href="http://www.youtube.com/watch?v=HZdKBqu0UWA">http://www.youtube.com/watch?v=HZdKBqu0UWA</a> voi nähdä, että<br
/>esimerkiksi 'n' - kirjain esiintyy kolmella eri leveydellä.<br
/>Merkkien kaventaminen tapahtuu jättämällä tietyt sarakkeet piirtämättä kokonaan.<br
/><br
/>Osoitteessa 0xD800 on fonttitaulukko. Joka merkille on 24 tavua, indeksoidaan yksinkertaisesti ascii-koodilla. Jokaista merkkiä varten on seuraavanlainen structi:<br
/>- offset 0: merkin ASCII-koodi<br
/>- offset 1: seuraavanlainen bittikenttä:<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 6: onko merkkille fonttidataa vai ei<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 0-2 ja 3-5: bittimaski välistystä (kerning) varten.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toinen merkin vasenta puolta ja toinen oikeaa puolta varten.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Ei varmaa, että kumpi on kumpi).<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kahden merkin välinen tyhjä sarake voidaan jättää pois,<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mikäli binäärinen AND vasemman merkin oikean puolen bittimaskin<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ja oikean merkin vasemman puolen bittimaskin kanssa on 0<br
/>- offset 2-3: Tuntematon 16-bittinen sana.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ainoastaan alemman tavun ylemmällä nybblellä merkitys.<br
/>- offset 4-13: 5 16-bittistä sanaa, yksi jokaista merkin saraketta kohti.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ylemmät 4 bittiä sisältävät metadataa,<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; joka kertoo mitkä sarakkeet voidaan tarvittaessa jättää piirtämättä.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tarkka formaatti tuntematon.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Alemmat 12 bittiä kertoo mitkä pikselit ovat päällä kyseisen<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sarakkeen yläpuoliskossa (ks. yllä lcd-väylän kuvauksesta)<br
/>- offset 14-23: 5 16-bittistä sanaa joka saraketta kohti.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kertoo vastaavasti kunkin sarakkeen alapuoliskon päällä<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; olevat pikselit.<br
/><br
/>Tämä voitaisin kirjoittaa puhtaaksi yhdessä jossain välissä:<br
/><br
/><b>Reverse engineering:&nbsp;</b><br
/><br
/>Kaikenlaista noista soodan keräämistä tiedoistakin irtoaa. Tällaisia päätelmiä ja arvauksia hardwaresta, näitä voisi todistella oikeiksi tai vääriksi todellisen hw:n äärellä:<br
/><br
/>Kortilla ei ole muuta EEPROMia kuin 28C64, nuo pienet piirit ovat TTL-PROMmeja (kertaohjelmoitava fuse-PROM). Isompi PROM näköjään sisältää oletustekstit. Pienempi tekee osoitteen dekoodauksen.<br
/><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Muistiavaruuden osoitekartta:<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000H...7FFFH -&gt; EPROM&nbsp; (32 kB)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8000H...BFFFH -&gt; RAM&nbsp;&nbsp;&nbsp; (blokki 16 kB, piiri 8 kB)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C000H...DFFFH -&gt; EEPROM (8 kB)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E000H...FFFFH -&gt; kalustamaton paikka (8 kB)<br
/><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I/O-avaruus on dekoodattu HCT138:lla. Piirien osoitteet ja ohjelman tekemät asetukset:<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10H...1FH = UART 1<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10H = data<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11H = control&nbsp; (7-E-1, 16x baud, RTS on, RXEN, TXEN)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Skoopilla mitaten tämä on 600 baud<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Menee modeemille, joka on toisella kortilla<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20H...2FH = UART 2<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20H = data<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 21H = control (8-N-1, 16x baud, RTS on, RXEN, TXEN)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9600 baudilla näkyy pc:llä juttuja<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30H...3FH = 8255<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30H = PA<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31H = PB<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32H = PC<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 33H = mode (PA out, PB out, PC in)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 40H...4FH = 8155<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 40H = mode (PA in, PB out, PC out)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 41H = PA<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 42H = PB<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 43H = PC<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 44H = timer hi<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 45H = timer lo<br
/><br
/>8155:n PB ja PC hoitavat ilmeisesti näytöille lähtevää väylää. Ohjelmassa on useita pieniä funktioita, joilla voi pulssittaa yksittäisiä C-portin bittejä, lähettää annetun datan sarjamuodossa bitti kerrallaan + strobe -tyylillä jostain portin bitistä ulos, heittää PB-portista one-hot-tyyppisiä valintoja ulos jne. Vaatii tarkempaa kaivelua, mikä 8155:n pinni menee mihinkäkin väylällä.<br
/><br
/>UARTtien baudinopeus pitää mitata. Tehdään mahdollisesti 8155:n timerillä + jakajilla, voi tulla suoraan 8085:n systeemikellostakin hard-wired, koska jakajia on riittävästi (4020 = 14-stage).<br
/>- Luultavasti ei 8155:ltä, koska koodi resetoi laskurin arvon vakioksi tietyin välein.<br
/><br
/>t. jari<br
/><br
/>Toiselta PCB:ltä mielenkiintoisinta on MC14412 - "Universal Low Speed Modem (0-600 bps)" sekä UART-jännitetasomuuntimet. LTG-portti menee tälle piirilevylle, ja se oli ainoa näytön kontrolliboksin ulkopuolelle mennyt piuha, joten aikamoisella varmuudella tuo modeemi on yhteydessä UART1:een. Etupaneelin testpointeilla pitäisi päästä tuohon UART:iin kiinni suoraan.<br
/><br
/>Koodissa luetaan useasti turhaan 11h-porttia, siihen lienee yhdistettynä<br
/>jokin watchdog-toiminnallisuus?<br
/><br
/>Tämä herättää ihmetystä, ei pitäisi olla tuollaista ominaisuutta 8251:ssä, eikä muutenkaan vaadi jatkuvaa pollausta.Tuo portti on UART1:n status-tavu.<br
/><br
/>- Jep, muuta järjellistä en tuolle keksinyt. Ehkä ajamalla tuo WD-test selviää mitä tapahtuu<br
/>(sen testin lopussa on ikuinen luuppi).<br
/>- WD-test sisältää muutakin debugprintiä (mm. taikanumeroita ja fontin nimen, sekä lopuksi piirtää koko näytön täyteen mustaa), ja looppaa loputtuaan taas alusta (ainakin toisen kerran, en katsonut pidempään) -sooda<br
/>- =&gt; siellä ihan oikeasti on jossain joku watchdog-viritys<br
/><br
/>4020 on ainut sen tyyppinen piiri, josta voisi saada WD:n. Arvaus: UART1:n chip select on viety 4020:n resettiin, ja jos 4020 pääsee laskemaan tarpeeksi pitkälle, se resetoi prosessorin. -- Ei toimi, 4020:n reset on ylhäällä aktiivinen, ja kortilla ei ole inverttereitä.<br
/><br
/>Joku viritys siellä on, joka vaatii UART1:n statuksen lukemista vähän väliä (IN 11H). Ilman tätä tulee noutaja.<br
/><br
/><br
/>8155 PA (portti 41h) on mapattu DIP-switcheihin. Niillä on seuraava funktio:<br
/>&nbsp;&nbsp;&nbsp; bit 7 -&nbsp;&nbsp; testitila. Pitäisi tulostaa joka segmenttiin jotain kamaa, sekä lopuksi<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WD-test eli watchdog test.<br
/>&nbsp;&nbsp;&nbsp; bit 4-6 - laitteen ID johon se reagoi UART1-väylällä<br
/>&nbsp;&nbsp;&nbsp; bit 1-3 - lisää ID-bittejä<br
/>&nbsp;&nbsp;&nbsp; bit 0 - poistaa käytöstä XOR-checksummin UART1-komentojen yhteydessä<br
/><br
/>Konsta taisi sanoa saaneensa 9600 baudilla dataa ulos RX/TX merkityillä pinneistä ("@I.@E-.@E+.@E+.@E+."), ja softa printtaileekin juuri tuommoista dataa UART2:een.<br
/>Mitään tuon ihmeempää ei UART2:sta sitten saakkaan, kaikki oikea info menee UART1:n päällä. Kuten ylempänä, UART1:n konffi ei ole se tavanomaisin, vaan 7 data-bittiä, 1 stop-bitti, ja even parity. Baudrate lienee sama.<br
/><br
/>Ok, hieman yksityiskohtaisemmin, UART2:lla voi tehdä kaksi asiaa.<br
/>- Bootissa tulee viesti "SPA-test N",<br
/>&nbsp;&nbsp;&nbsp; missä N laskee kakkosesta nollaan. Heittämällä rivinvaihdon 0xC UART2:een<br
/>&nbsp;&nbsp;&nbsp; tuon testin saa keskeytettyä ja jatkettua boottia.<br
/>-&nbsp;&nbsp; E-komennon yhteydessä (alempana selitetty) saa UART2:een jonkun muuttujan<br
/>&nbsp;&nbsp;&nbsp; tulosteen, jos sieltä löytyy tavu ':'.<br
/><br
/>UART1:n kommunikaatio on hyvin pitkälle ASCII-pohjaista. Eli esim. boolean-arvot kulkee väylällä ASCII-'0' ja ASCII-'1':nä, kuten kaikki muutkin lukuarvot.<br
/><br
/>UART1:stä luvussa on kolme vaihetta:<br
/>&nbsp;&nbsp;&nbsp; - osoitettavan laitteen valinta<br
/>&nbsp;&nbsp;&nbsp; - komentopuskurin lataus (0x2)<br
/>&nbsp;&nbsp;&nbsp; - komennon suoritus (0x4)<br
/><br
/>Osoite muodostuu seuraavasti:<br
/>&nbsp;&nbsp;&nbsp; - laitteen ID ASCII-numerona, eli '0'-'7'. Tämä tulee DIP-switchin biteistä 4-6<br
/>&nbsp;&nbsp;&nbsp; - toinen ID ASCIIna (DIPin biteistä 1-3) LSL 1. Alin bitti kertoo nyt luetaanko(0) vaiko kirjoitetaanko (1) näytöltä/näytölle<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - esim. jos DIP[1:3] = '001' ja halutaan kirjoittaa näytölle, niin 2. tavuksi halutaan '3'<br
/>&nbsp;&nbsp;&nbsp; - ASCII ENQ (0x5) päättää osoitevaiheen<br
/><br
/>Kirjoitustilassa laite jää odottelemaan ASCII STXää (0x2), jonka jälkeen luetaan komentoja terminoituna ASCII ETX:llä (0x3) sekä checksum-tavu.<br
/>Checksum on yksinkertainen XOR komentotavuista.<br
/>(ETX lasketaan checksummiin, STX ei, TOISIN KUIN ENNEN MAINITSIN)<br
/>Tämän checksum-tarkastuksen saa dip-switchin nollabitillä pois.<br
/><br
/>Komentopuskurin tavu #8 kertoo mitä tapahtuu:<br
/><br
/>'E':<br
/>&nbsp;&nbsp;&nbsp; Valitsee mitä ruudulla näkyy, sisältö tulee 8kb EEPROMista<br
/><br
/>&nbsp;&nbsp;&nbsp; Data bytes have the following meaning:<br
/>&nbsp;&nbsp;&nbsp; #00: constant 0x2, the command byte<br
/>&nbsp;&nbsp;&nbsp; #01: unknown, NOT A STRING VALUE AS WAS MENTIONED BEFORE!<br
/>&nbsp;&nbsp;&nbsp; #02: unknown value related to clock+blinker. Compared to '0' and '1'.<br
/>&nbsp;&nbsp;&nbsp; #03-#05 expected version number of the string ROM. If incorrect,<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error code '3' is set.<br
/>&nbsp;&nbsp;&nbsp; ...<br
/>&nbsp;&nbsp;&nbsp; #08: constant 'E', the command byte<br
/>&nbsp;&nbsp;&nbsp; #09: Tenths digit of the minutes to train ETA (ASCII)<br
/>&nbsp;&nbsp;&nbsp; #0a: Ones digit of the minutes to train ETA (ASCII)<br
/>&nbsp;&nbsp;&nbsp; #0b: Unknown, not used?<br
/>&nbsp;&nbsp;&nbsp; #0c: Animation frame of the blinker (ASCII number), 0 = empty<br
/>&nbsp;&nbsp;&nbsp; #0d: HiByte of the first (finnish) text line's key.<br
/>&nbsp;&nbsp;&nbsp; #0e: LoByte of the first (finnish) text line's key.<br
/>&nbsp;&nbsp;&nbsp; #0f: HiByte of the second (swedish) text line's key.<br
/>&nbsp;&nbsp;&nbsp; #10: LoByte of the second (swedish) text line's key.<br
/>&nbsp;&nbsp;&nbsp; #11: Generate a debug message (@E+.) to UART2 if not '0'.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Then, if UART2 contains ':', print some more (unknown) data to UART2<br
/><br
/>'D':<br
/>&nbsp;&nbsp;&nbsp; This subcommand can modify the String EEPROM.<br
/>&nbsp;&nbsp;&nbsp; Data bytes:<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - If bytes #01, #02, #06, #07 are all '0',<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all String EEPROM data WILL BE ERASED after the execute command (4)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Otherwise, a new key-value pair is appended to the string EEPROM.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bytes #01, #02, #06, #07 contain the four-byte key.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; All the bytes at #09 are copied as the String value,<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terminated by the ASCII ETX (3) that also ended the command buffer!.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Then the ROM version is set to bytes #3-#5 and the version<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is checksummed. (See below for definition of ROM version)<br
/><br
/>'T':<br
/>&nbsp;&nbsp;&nbsp; This prints a string!!<br
/>&nbsp;&nbsp;&nbsp; Data bytes:<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #00: 0x2, the STX<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #01-#02: Segment parameter! (See later for definition)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #06: Some display param? Checks for one of "sbn".<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #07: Positioning? Checks for one of "lrmz".<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #08: The command byte 'T'.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #09: The string! Terminated by ASCII ETX (0x3), which also<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ended the command buffer!<br
/><br
/>'N':<br
/>&nbsp;&nbsp;&nbsp; Clears the screen?<br
/>&nbsp;&nbsp;&nbsp; Data bytes:<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #01-#02: Segment parameter.<br
/><br
/>Komentopuskurin antamisen jälkeen komento suoritetaan kirjoittamalla ASCII EOT (0x4).<br
/>EOT:n kirjoittaminen väylälle palauttaa näytön aina alkutilaan (eli odottamaan näytön osoitetta). Samaten jonkinnäköinen timeout siellä on.<br
/><br
/>Komentopuskurin luonti ja sen suoritus on erikseen luultavasti siksi, että jotkut operaatiot voivat asettaa virhekoodin komentopuskurin antovaiheessa (esim jos EEPROMilta loppuu tila D-komennon yhteydessä).<br
/><br
/>Virhekoodin saa luettua sanomalla osoitevaiheessa (tokan tavun lsb = 0), mutta vastauksen&nbsp; rakenne riippuu siitä, mikä komento aktivoitiin viimeisessä komentopuskurissa. Valitsemalla lukuoperaation pitäisi UART1:een tulla tulostetta, ja samalla päätyy johonkin moodiin, jossa<br
/>&nbsp;komentotavut on eroteltu 0x10- ja 0x31-tavuilla (vastaavasti kuin kirjoitustilassa komentotavut erottaa STX ja ETX). Nähdäkseni tuossa koodissa on kuitenkin bugi (ehdollisissa hypyissä pari ehtoa väärinpäin), eikä kyseeisessä moodissa voi tehdä mitään hyödyllistä.<br
/><br
/>Komennon antaminen muuttaa myös softan sisäistä tilaa siinä mielessä, että&nbsp;<br
/>E-komennon antamisen jälkeen laite osaa itse vilkuttaa sekunttivilkutinta ja päivittää minuuttilaskuria. Tämä feature menee pois päältä T-komennon annettaessa.<br
/>Näyttänee tosin myös siltä, että jos UART1:ssä ei liiku dataa hetkeen, resetoituu<br
/>laite näyttämään Ruoholahtea jonkin ajan (3 minuuttia?) päästä.<br
/><br
/>Eli esimerkkikirjoituskomento (lista tavuja)<br
/>&nbsp;&nbsp;&nbsp; [DIP[4:6] | '0', (DIP[1:3] &lt;&lt; 1) | 1 | '0', ENQ, STX, segmentHi, segmentLo, ?, ?, ?, ?, ?, 'N', ETX, checksum, EOT]<br
/>&nbsp;&nbsp;&nbsp; ? = (lähes) mielivaltainen tavu, vaikkapa 'a' on turvallinen<br
/><br
/>Esimerkkilukukomento:<br
/>&nbsp;&nbsp;&nbsp; [DIP[4:6] | '0', (DIP[1:3] &lt;&lt; 1) | '0', ENQ]<br
/>&nbsp;&nbsp;&nbsp; Tällä pitäisi siis jotain tulostua. Kannattaa odotella hetki ennen uusien komentojen laittamista jos tätä yrittää.<br
/><br
/>LCD segment parameter:<br
/>&nbsp;&nbsp;&nbsp; The PrintString takes in HL a word describing which segment to fill. Values used are:<br
/>&nbsp;&nbsp;&nbsp; (Also, the N and T commands)h<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 0x101 for the finnish text<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 0x201 for the swedish text<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 0x301 for the clock?<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 0x302 for the blinking thingy? NOT SURE<br
/><br
/>Ohjelmakoodi on kaksiosainen: itse LCD:lle kommunikaatio on kirjoitettu C:llä, alkaa osoitteesta 0x4000, ja koko muu hela hoito on assembleria, alkaa 0x0:sta.<br
/>Tuo C-osuus on niin hirveää luettavaa, etten ole siihen perehtynyt.<br
/>Tuon assembler-osuuden sen sijaan selvittänyt koodin osalta melkeinpä perinpohjaisesti,<br
/>muuttujia en ihan niin paljoa.<br
/><br
/>Tietääkseni 8085:lle ei ollut mitään asiallista (tai asiatontakaan) C-kääntäjää tarjolla vuonna 90, veikkaan PL/M:ää. Korkean tason kielestä käännettyä kuitenkin.<br
/><br
/>Merkkijono-EEPROMin formaatti<br
/><br
/>#00:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seuraavan kuuden tavun XOR-checksum. Jos ei mätsää,<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; koko EEPROM tyhjennetään 'e':ksi.<br
/>#01-03:&nbsp;&nbsp;&nbsp; Merkkijono-EEPROMin versionumero, ASCII-numeroita.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E-komento vertaa komentopuskurissa annettua versionumeroa,<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ja antaa virheen jos nämä eivät ole samat. D-komennolla<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EEPROMin versionumero voidaan asettaa kirjoituksen yhteydessä.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Dumpatulta teksti-EEPROMilta löytyy muistaakseni '004')<br
/>#04-05:&nbsp;&nbsp;&nbsp; Osoitin seuraavaan vapaaseen tavuun EEPROMille. Tähän kohtaan D-komento<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; appendaa lisättävän avain-arvoparin.<br
/>...#0f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Taikanumero 'MHELS\x17'.<br
/>#10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x2, aloittaa merkkijonolistan<br
/>#11..&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n kpl avain-merkkijono-pareja eroteltuna 0x2:lla. Avain on aina 4 ASCII-tavua,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esim 1B01, ja tuota muotoa. 1Bxx on ekan rivin avain ja 2Bxx tokan rivin.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Listan päättää erotin 0x2. Loput on oletuksena täytetty 'e'-merkillä.<br
/>#1ffe-#1fff: Taikanumerot 0x17. Nämä ilmaisevat merkkijononkopiointirutiineille<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROM:n loppumisen. Samaan tapaan MHELS-signaturen 0x17<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kertoo ROM:n toisen pään, sillä hakurutiini tekee läpikäynnin lopusta alkuun.<br
/><br
/>Disclaimer, ylläoleva on *puhtaasti* disassembloimalla saatua tietoa, ihme jos tuolla ei jotain virheitä ole. Assembly-puolen koodista vapaasti saa kysellä, varmaan ehdin vastatakin joskus.<br
/><br
/>-Dezgeg (Tuomas)<br
/><br
/><br
/>--------------------------------------------------------<br
/><br
/>14.3. session tuloksia<br
/><br
/>EPROMin disassembly käännettiin netistä löytyneellä 8085-assemblerilla. Muutaman korjailun jälkeen (myös kääntäjä itse vaati korjailua) kääntäjän tuottama intel-hex on identtinen alkuperäisen EPROMista luetun kanssa.<br
/><br
/>Ohjaimen piirilevyllä oleva EPROM korvattiin Romulaattorilla (ROM-emulaattori) johon ladattiin kääntäjän tuotos. Näyttö jatkoi toimintaansa samoin kun ennenkin, eli siis toimii Romulaattorin kanssa.&nbsp;<br
/><br
/>Koodia muokkaamalla saatiin näytölle ensin omia kiinteitä tekstejä. Seuraavaksi tehtiin yksinkertainen skrolleri, josta on alussa linkitetty video. Lopuksi muokattu koodi ohjelmoitiin EPROMiin.<br
/><br
/>Havaintoja ohjelmasta:<br
/><br
/><ul><li>Osoitteesta 4000H alkava funktio kirjoittaa tekstin näytölle. Parametrit:<ul><li>&nbsp;&nbsp;&nbsp; DE = pointteri tekstiin, asciiz</li
><li>&nbsp;&nbsp;&nbsp; H = tekstin sijainti näytöllä<ul><li>01 = ylärivi</li
><li>02 = alarivi</li
><li>03 = näytön oikea laita (aikanäytön alue)</li></ul
></li
><li>&nbsp;&nbsp;&nbsp; L = kummalla puolella näyttöä teksti on (ei varmistettu, kun toinen puoli pöytää vasten :P)<br/><br
/></li></ul
></li
><li>Osoitteesta 00A0H alkava funktio on viivelooppi, viiveen pituus BC:ssä. Videossa näkyvä skrollerin askelten väliaika on saatu arvolla BC = 07FFH.<br/><br
/></li
><li>IN 11H käskyä pitää viljellä koodissa, muuten laukeaa vahtikoira.<br/><br
/></li
><li>Videossa näkyvä fonttien villi leveneminen ja kapeneminen on näytön omaa logiikkaa, kun se pyrkii optimoimaan tekstiä siten, että näyttöpaneelien välipalkki osuu aina kirjainten väliin ja kirjainten välit ovat muuten tasaiset.<br/><br
/></li></ul
>-- jari<br
/><br
/>Mä olen purakunut osoitteesta 4000H alkavaa koodia<br
/><br
/>L4000: hyppää suoraan L59A1<br
/>L59A1: kopioi parametrit pinoon jäejestyksessä L, H, DE<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kutsu rutiinia L56E4<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poista L, H ja DE pinosta ja palaa<br
/>L56E4: Varaa tilaa pinosta (lokaaleille muuttujille) 6 tavua (eli 3 sanaa)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tarkista, että L &lt;=3 ja H&lt;= 2. Jos ei poista 6 tavua pinosta ja palaa<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Jos parametrit on oikein, hyppää labeliin L571B<br
/>L570E: edellisen apulabeli (nollaa Zero flagin)<br
/>L5711: L56E4:n apulabel (jos Zero flagi ei asetettu, poista varatut 6 tavua pinosta ja palaa)<br
/>L5B52: hl &lt;= de paluuarvo Zero flagissa (0=false, 1=true) toteutettu vaihtamalla rekisterit<br
/>L5B53: de &lt;= hl paluuarvo kuten ylhäällä<br
/>L5B62: edellisen apulabeli (erisuuruuden tarkastelu jos hl de erimerkkiset)<br
/><br
/>--juha<br
/><br
/></body>
</html>
