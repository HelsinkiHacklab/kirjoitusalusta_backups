<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-type"/>
  <meta content="en-us" http-equiv="Content-Language"/>
  <title>
   /hacklab-kurssi-digi-3
  </title>
 </head>
 <body>
  Tämä sivu:
  <a href="./hacklab-kurssi-digi-3.html">
   https://kirjoitusalusta.fi/hacklab-kurssi-digi-3
  </a>
  <br/>
  <br/>
  <br/>
  <br/>
  <a href="https://www.dropbox.com/sh/8xmlf8xr743vz2m/AAC0eoMfUh1PAfLNouciWw3oa?dl=0">
   https://www.dropbox.com/sh/8xmlf8xr743vz2m/AAC0eoMfUh1PAfLNouciWw3oa?dl=0
  </a>
  <br/>
  <br/>
  (tuolta löytyy myös 'sample_11025_8bit_1473669samples' tiedostot)
  <br/>
  <br/>
  -----
  <br/>
  <br/>
  <b>
   Digitaalitekniikka-3, FPGA-jatko
  </b>
  <br/>
  <br/>
  <br/>
  <ul>
   <li>
    <a href="https://discourse.hacklab.fi/t/digi-3-jatko/XXX">
     https://discourse.hacklab.fi/t/digi-3-jatko/XXX
    </a>
    <br/>
    <br/>
    <br/>
    <br/>
   </li>
  </ul>
  -- samplen luku muistista:
  <br/>
  <br/>
  // Delta-sigma version
  <br/>
  <br/>
  `timescale 1ns / 1ps
  <br/>
  `default_nettype none
  <br/>
  <br/>
  module DeltaSigmaDAC(
  <br/>
  input   wire                clock,
  <br/>
  input   wire    [7:0]       sample_in,
  <br/>
  output  reg                 audio_out
  <br/>
  );
  <br/>
  <br/>
  initial audio_out = 1'b0;
  <br/>
  <br/>
  reg [7:0]   accumulator = 8'd0;
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  { audio_out, accumulator } &lt;= accumulator + sample_in;
  <br/>
  end
  <br/>
  <br/>
  endmodule
  <br/>
  <br/>
  <br/>
  module SampleMemory #(
  <br/>
  parameter                            N = 11_025*4,
  <br/>
  parameter                            ADDRESS_BITS = $clog2(N),
  <br/>
  parameter                            DATA_BITS = 8
  <br/>
  ) (
  <br/>
  input   wire                        clock,
  <br/>
  input   wire    [ADDRESS_BITS-1:0]  read_address,
  <br/>
  output  reg     [DATA_BITS-1:0]     data_out
  <br/>
  );
  <br/>
  <br/>
  (* ram_style = "block" *)
  <br/>
  reg [DATA_BITS-1:0]     mem[2**ADDRESS_BITS-1:0];
  <br/>
  <br/>
  initial begin
  <br/>
  //$readmemb("sample_11025_8bit_1473669samples.raw", mem);
  <br/>
  $readmemh("sample_11025_8bit_1473669samples.txt", mem);
  <br/>
  end
  <br/>
  <br/>
  initial    data_out = 1'd0;
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  data_out &lt;= mem[read_address];
  <br/>
  end
  <br/>
  <br/>
  endmodule
  <br/>
  <br/>
  <br/>
  module Main #(
  <br/>
  parameter                        EXTERNAL_CLOCK_FREQUENCY_HZ = 50_000_000,
  <br/>
  parameter                        EXTERNAL_CLOCK_PERIOD_NS = 1000000000.0/EXTERNAL_CLOCK_FREQUENCY_HZ
  <br/>
  ) (
  <br/>
  input    wire                 CLOCK,
  <br/>
  output   wire                 AUDIO_OUT
  <br/>
  );
  <br/>
  <br/>
  wire     clock = CLOCK;
  <br/>
  <br/>
  reg     [$clog2(EXTERNAL_CLOCK_FREQUENCY_HZ/11025):0]    count8kHz = 1'd0;
  <br/>
  reg     [31:0]                                          t = 32'd0;
  <br/>
  wire    [7:0]                                           sample;
  <br/>
  <br/>
  DeltaSigmaDAC dac0(
  <br/>
  .clock(clock),
  <br/>
  .sample_in(sample),
  <br/>
  .audio_out(AUDIO_OUT)
  <br/>
  );
  <br/>
  <br/>
  SampleMemory sample_memory(
  <br/>
  .clock(clock),
  <br/>
  .read_address(t),
  <br/>
  .data_out(sample)
  <br/>
  );
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  if (count8kHz == (EXTERNAL_CLOCK_FREQUENCY_HZ/11025) - 1) begin
  <br/>
  count8kHz &lt;= 1'd0;
  <br/>
  t &lt;= t + 1'd1;
  <br/>
  end else begin
  <br/>
  count8kHz &lt;= count8kHz + 1'd1;
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  endmodule
  <br/>
  <br/>
  <br/>
  <br/>
  --
  <br/>
  <br/>
  Tostai 21.4.:
  <br/>
  <br/>
  // Delta-sigma version
  <br/>
  <br/>
  `timescale 1ns / 1ps
  <br/>
  `default_nettype none
  <br/>
  <br/>
  module DeltaSigmaDAC(
  <br/>
  input   wire                clock,
  <br/>
  input   wire    [7:0]       sample_in,
  <br/>
  output  reg                 audio_out
  <br/>
  );
  <br/>
  <br/>
  initial audio_out = 1'b0;
  <br/>
  <br/>
  reg [7:0]   accumulator = 8'd0;
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  { audio_out, accumulator } &lt;= accumulator + sample_in;
  <br/>
  end
  <br/>
  <br/>
  endmodule
  <br/>
  <br/>
  <br/>
  module Main #(
  <br/>
  parameter                        EXTERNAL_CLOCK_FREQUENCY_HZ = 50_000_000,
  <br/>
  parameter                        EXTERNAL_CLOCK_PERIOD_NS = 1000000000.0/EXTERNAL_CLOCK_FREQUENCY_HZ
  <br/>
  ) (
  <br/>
  input    wire                 CLOCK,
  <br/>
  output   wire                 AUDIO_OUT
  <br/>
  );
  <br/>
  <br/>
  wire     clock = CLOCK;
  <br/>
  <br/>
  reg     [$clog2(EXTERNAL_CLOCK_FREQUENCY_HZ):0]     count8kHz = 1'd0;
  <br/>
  reg     [31:0]                                      t = 32'd0;
  <br/>
  reg     [7:0]                                       sample = 8'd0;
  <br/>
  <br/>
  DeltaSigmaDAC dac0(
  <br/>
  .clock(clock),
  <br/>
  .sample_in(sample),
  <br/>
  .audio_out(AUDIO_OUT)
  <br/>
  );
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  if (count8kHz == (EXTERNAL_CLOCK_FREQUENCY_HZ/8000) - 1) begin
  <br/>
  count8kHz &lt;= 1'd0;
  <br/>
  t &lt;= t + 1'd1;
  <br/>
  <br/>
  //
  <a href="http://wurstcaptures.untergrund.net/music/?oneliner=10">
   http://wurstcaptures.untergrund.net/music/?oneliner=10
  </a>
  *((t%3E%3E7)%7Ct%7C(t%3E%3E6))%2B((t%26(t%3E%3E13)%7C(t%3E%3E6))%3C%3C%202)&amp;oneliner2=&amp;t0=0&amp;tmod=0&amp;duration=120&amp;separation=100&amp;rate=8000
  <br/>
  sample &lt;= 10*((t&gt;&gt;7)|t|(t&gt;&gt;6))+((t&amp;(t&gt;&gt;13)|(t&gt;&gt;6))&lt;&lt; 2);
  <br/>
  <br/>
  end else begin
  <br/>
  count8kHz &lt;= count8kHz + 1'd1;
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  endmodule
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  Tostai 14.4.:
  <br/>
  <br/>
  <br/>
  ---- Esimerkkikoodi 2:
  <br/>
  // main.v
  <br/>
  <br/>
  `timescale 1ns / 1ps
  <br/>
  `default_nettype none
  <br/>
  <br/>
  <br/>
  <br/>
  // DFF with synchronous reset and clock enable
  <br/>
  module DFF(
  <br/>
  input   wire        clock,
  <br/>
  input   wire        reset,
  <br/>
  input   wire        enable,
  <br/>
  input   wire        d,
  <br/>
  output  reg         q
  <br/>
  );
  <br/>
  <br/>
  initial             q = 1'b0;
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  if (reset) begin
  <br/>
  q &lt;= 1'b0;
  <br/>
  end else if (enable) begin
  <br/>
  q &lt;= d;
  <br/>
  end
  <br/>
  end
  <br/>
  endmodule
  <br/>
  <br/>
  <br/>
  module main #(
  <br/>
  parameter                        EXTERNAL_CLOCK_FREQUENCY_HZ = 100_000_000,
  <br/>
  parameter                        EXTERNAL_CLOCK_PERIOD_NS = 1000000000.0/EXTERNAL_CLOCK_FREQUENCY_HZ
  <br/>
  ) (
  <br/>
  input    wire                     CLOCK,
  <br/>
  output  wire    [7:0]             LED
  <br/>
  );
  <br/>
  <br/>
  <br/>
  wire                        clock = CLOCK;
  <br/>
  reg    [$clog2(EXTERNAL_CLOCK_FREQUENCY_HZ)-1:0] second_counter = 1'd0;
  <br/>
  reg    second_strobe = 1'b0;
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  if (second_counter != EXTERNAL_CLOCK_FREQUENCY_HZ) begin
  <br/>
  second_counter &lt;= second_counter + 1'd1;
  <br/>
  second_strobe &lt;= 1'b0;
  <br/>
  end else begin
  <br/>
  second_counter &lt;= 1'd0;
  <br/>
  second_strobe &lt;= 1'b1;
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  /*
  <br/>
  wire            dff_q;
  <br/>
  DFF        dff(
  <br/>
  .clock(clock),
  <br/>
  .reset(1'b0),
  <br/>
  .enable(second_strobe),
  <br/>
  .d(~dff_q),
  <br/>
  .q(dff_q)
  <br/>
  );
  <br/>
  */
  <br/>
  wire            dff_q;
  <br/>
  FDRE dff(
  <br/>
  .C(clock),          // 1-bit Clock input
  <br/>
  .R(1'b0),              // 1-bit Synchronous reset input
  <br/>
  .CE(second_strobe), // 1-bit Clock enable input
  <br/>
  .D(~dff_q),           // 1-bit Data input
  <br/>
  .Q(dff_q)          // 1-bit Data output
  <br/>
  );
  <br/>
  <br/>
  <br/>
  assign LED = { 8{ dff_q } };
  <br/>
  <br/>
  endmodule
  <br/>
  <br/>
  <br/>
  <br/>
  ---- Esimerkkikoodi 1:
  <br/>
  <br/>
  // main.v
  <br/>
  <br/>
  `timescale 1ns / 1ps
  <br/>
  `default_nettype none
  <br/>
  <br/>
  module main #(
  <br/>
  parameter                        EXTERNAL_CLOCK_FREQUENCY_HZ = 100_000_000,
  <br/>
  parameter                        EXTERNAL_CLOCK_PERIOD_NS = 1000000000.0/EXTERNAL_CLOCK_FREQUENCY_HZ
  <br/>
  ) (
  <br/>
  input    wire                     CLOCK,
  <br/>
  output  wire    [7:0]             LED
  <br/>
  );
  <br/>
  <br/>
  <br/>
  wire                        clock = CLOCK;
  <br/>
  reg    [$clog2(EXTERNAL_CLOCK_FREQUENCY_HZ)-1:0] second_counter = 1'd0;
  <br/>
  reg    second_strobe = 1'b0;
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  if (second_counter != EXTERNAL_CLOCK_FREQUENCY_HZ) begin
  <br/>
  second_counter &lt;= second_counter + 1'd1;
  <br/>
  second_strobe &lt;= 1'b0;
  <br/>
  end else begin
  <br/>
  second_counter &lt;= 1'd0;
  <br/>
  second_strobe &lt;= 1'b1;
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  reg        [7:0]    led = 8'b00000000;
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  if (second_strobe) begin
  <br/>
  led = ~led;
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  assign LED = led;
  <br/>
  <br/>
  endmodule
  <br/>
  <br/>
  <br/>
  <br/>
 </body>
</html>