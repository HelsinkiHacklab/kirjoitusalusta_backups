<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-type"/>
  <meta content="en-us" http-equiv="Content-Language"/>
  <title>
   /hacklab-kurssi-digi-3
  </title>
 </head>
 <body>
  Tämä sivu:
  <a href="./hacklab-kurssi-digi-3.html">
   https://kirjoitusalusta.fi/hacklab-kurssi-digi-3
  </a>
  <br/>
  <br/>
  <b>
   Digitaalitekniikka-3, FPGA-jatko
  </b>
  <br/>
  <br/>
  // Serial input/output echo with "ab..z" -&gt; "AB..Z" capitalization
  <br/>
  <br/>
  `timescale 1ns / 1ps
  <br/>
  `default_nettype none
  <br/>
  <br/>
  <br/>
  module SerialInput #(
  <br/>
  parameter                        CLOCK_FREQUENCY_HZ = 0,
  <br/>
  parameter                        BITS_PER_SECOND = 0,
  <br/>
  parameter                        TIMER_VALUE_PER_BIT = CLOCK_FREQUENCY_HZ/BITS_PER_SECOND
  <br/>
  ) (
  <br/>
  input   wire                clock,
  <br/>
  input   wire                rxd,
  <br/>
  <br/>
  output  reg     [8-1:0]     data,
  <br/>
  output  reg                 available
  <br/>
  );
  <br/>
  initial $display("SerialInput # CLOCK_FREQUENCY_HZ = %.3f, BITS_PER_SECOND = %d, TIMER_VALUE_PER_BIT = %d", CLOCK_FREQUENCY_HZ, BITS_PER_SECOND, TIMER_VALUE_PER_BIT);
  <br/>
  <br/>
  initial                     available &lt;= 1'b0;
  <br/>
  initial                        data &lt;= 8'd0;
  <br/>
  <br/>
  parameter RESET =              3'b000;
  <br/>
  parameter IDLE =            3'b001;
  <br/>
  parameter START_BIT =         3'b010;
  <br/>
  parameter DATA_BITS =       3'b011;
  <br/>
  parameter STOP_BIT =        3'b100;
  <br/>
  <br/>
  reg        [3-1:0]                state =         RESET;
  <br/>
  reg                            timeout =        1'b0;
  <br/>
  reg        [16-1:0]            timer =         1'd0;
  <br/>
  reg        [3-1:0]                count =         1'd0;
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  if (!timeout) begin
  <br/>
  {timeout, timer} &lt;= timer - 1'd1;
  <br/>
  end
  <br/>
  <br/>
  available &lt;= 1'b0;
  <br/>
  <br/>
  case (state)
  <br/>
  RESET: begin
  <br/>
  if (rxd == 1'b0) begin
  <br/>
  {timeout, timer} &lt;= TIMER_VALUE_PER_BIT/2;
  <br/>
  end else if (timeout) begin
  <br/>
  state &lt;= IDLE;
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  IDLE: begin
  <br/>
  if (rxd == 1'b0) begin
  <br/>
  state &lt;= START_BIT;
  <br/>
  {timeout, timer} &lt;= TIMER_VALUE_PER_BIT/2;
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  START_BIT: begin
  <br/>
  if (timeout) begin
  <br/>
  {timeout, timer} &lt;= TIMER_VALUE_PER_BIT;
  <br/>
  if (rxd == 1'b0) begin
  <br/>
  state &lt;= DATA_BITS;
  <br/>
  count &lt;= 1'd0;
  <br/>
  end else begin
  <br/>
  state &lt;= RESET;
  <br/>
  end
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  DATA_BITS: begin
  <br/>
  if (timeout) begin
  <br/>
  {timeout, timer} &lt;= TIMER_VALUE_PER_BIT;
  <br/>
  count &lt;= count + 1'd1;
  <br/>
  data &lt;= { rxd, data[7:1] };
  <br/>
  if (count == 'd7) begin
  <br/>
  state &lt;= STOP_BIT;
  <br/>
  end
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  STOP_BIT: begin
  <br/>
  if (timeout) begin
  <br/>
  if (rxd == 1'b1) begin
  <br/>
  state &lt;= IDLE;
  <br/>
  available &lt;= 1'b1;
  <br/>
  end else begin
  <br/>
  state &lt;= RESET;
  <br/>
  end
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  endcase
  <br/>
  end
  <br/>
  endmodule
  <br/>
  <br/>
  <br/>
  module SerialOutput #(
  <br/>
  parameter                        CLOCK_FREQUENCY_HZ = 0,
  <br/>
  parameter                        BITS_PER_SECOND = 0,
  <br/>
  parameter                        TIMER_VALUE_PER_BIT = CLOCK_FREQUENCY_HZ/BITS_PER_SECOND
  <br/>
  ) (
  <br/>
  input   wire                clock,
  <br/>
  input    wire    [8-1:0]     data,
  <br/>
  input      wire                available,
  <br/>
  <br/>
  output    reg                    busy,
  <br/>
  output  reg                   txd
  <br/>
  );
  <br/>
  initial $display("SerialInput # CLOCK_FREQUENCY_HZ = %.3f, BITS_PER_SECOND = %d, TIMER_VALUE_PER_BIT = %d", CLOCK_FREQUENCY_HZ, BITS_PER_SECOND, TIMER_VALUE_PER_BIT);
  <br/>
  <br/>
  initial                        busy = 1'b0;
  <br/>
  initial                        txd = 1'b1;
  <br/>
  <br/>
  parameter RESET =              3'b000;
  <br/>
  parameter IDLE =            3'b001;
  <br/>
  parameter START_BIT =         3'b010;
  <br/>
  parameter DATA_BITS =       3'b011;
  <br/>
  parameter STOP_BIT =        3'b100;
  <br/>
  <br/>
  reg        [3-1:0]                state =         IDLE;
  <br/>
  reg                            timeout =        1'b0;
  <br/>
  reg        [16-1:0]            timer =         1'd0;
  <br/>
  reg        [4-1:0]                count =         1'd0;
  <br/>
  <br/>
  reg        [8-1:0]                data_reg =         8'b00000000;
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  if (!timeout) begin
  <br/>
  {timeout, timer} &lt;= timer - 1'd1;
  <br/>
  end
  <br/>
  <br/>
  case (state)
  <br/>
  IDLE: begin
  <br/>
  if (available) begin
  <br/>
  data_reg &lt;= data;
  <br/>
  state &lt;= START_BIT;
  <br/>
  busy &lt;= 1'b1;
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  START_BIT: begin
  <br/>
  {timeout, timer} &lt;= TIMER_VALUE_PER_BIT;
  <br/>
  state &lt;= DATA_BITS;
  <br/>
  count &lt;= 1'd0;
  <br/>
  txd &lt;= 1'b0;
  <br/>
  end
  <br/>
  <br/>
  DATA_BITS: begin
  <br/>
  if (timeout) begin
  <br/>
  {timeout, timer} &lt;= TIMER_VALUE_PER_BIT;
  <br/>
  if (count == 'd8) begin
  <br/>
  state &lt;= STOP_BIT;
  <br/>
  txd &lt;= 1'b1;
  <br/>
  end else begin
  <br/>
  count &lt;= count + 1'd1;
  <br/>
  txd &lt;= data_reg[0];
  <br/>
  data_reg &lt;= { 1'b0, data_reg[7:1] };
  <br/>
  end
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  STOP_BIT: begin
  <br/>
  if (timeout) begin
  <br/>
  state &lt;= IDLE;
  <br/>
  busy &lt;= 1'b0;
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  endcase
  <br/>
  end
  <br/>
  <br/>
  endmodule
  <br/>
  <br/>
  module Main #(
  <br/>
  parameter                    CLOCK_FREQUENCY_HZ = 50_000_000,
  <br/>
  parameter                    CLOCK_PERIOD_NS = 1000000000.0/CLOCK_FREQUENCY_HZ
  <br/>
  ) (
  <br/>
  input    wire                   CLOCK,
  <br/>
  <br/>
  output    reg     [7:0]             LED,
  <br/>
  <br/>
  input    wire                SERIAL_RXD,
  <br/>
  output    wire                SERIAL_TXD
  <br/>
  );
  <br/>
  initial $display("Main # CLOCK_FREQUENCY_HZ = %.3f, CLOCK_PERIOD_NS = %.3f", CLOCK_FREQUENCY_HZ, CLOCK_PERIOD_NS);
  <br/>
  <br/>
  initial LED = 8'b01010101;
  <br/>
  <br/>
  wire     clock = CLOCK;
  <br/>
  <br/>
  <br/>
  wire    [7:0]                                rxd_data;
  <br/>
  wire                                        rxd_available;
  <br/>
  SerialInput #(
  <br/>
  .CLOCK_FREQUENCY_HZ(CLOCK_FREQUENCY_HZ),
  <br/>
  .BITS_PER_SECOND(115200)
  <br/>
  ) serial_rxd(
  <br/>
  .clock(clock),
  <br/>
  .rxd(SERIAL_RXD),
  <br/>
  <br/>
  .data(rxd_data),
  <br/>
  .available(rxd_available)
  <br/>
  );
  <br/>
  <br/>
  reg    [7:0]                                txd_data = 8'd0;
  <br/>
  reg                                        txd_available = 1'b0;
  <br/>
  wire                                    txd_busy;
  <br/>
  SerialOutput #(
  <br/>
  .CLOCK_FREQUENCY_HZ(CLOCK_FREQUENCY_HZ),
  <br/>
  .BITS_PER_SECOND(115200)
  <br/>
  ) serial_txd(
  <br/>
  .clock(clock),
  <br/>
  .data(txd_data),
  <br/>
  .available(txd_available),
  <br/>
  <br/>
  .busy(txd_busy),
  <br/>
  .txd(SERIAL_TXD)
  <br/>
  );
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  if (rxd_available) begin
  <br/>
  LED &lt;= rxd_data;
  <br/>
  <br/>
  if (rxd_data &gt;= 97 &amp;&amp; rxd_data &lt;= 122) begin
  <br/>
  txd_data &lt;= rxd_data - 32;
  <br/>
  end else begin
  <br/>
  txd_data &lt;= rxd_data;
  <br/>
  end
  <br/>
  txd_available &lt;= 1'b1;
  <br/>
  end else begin
  <br/>
  txd_available &lt;= 1'b0;
  <br/>
  end
  <br/>
  end
  <br/>
  endmodule
  <br/>
  <br/>
  <br/>
  -----
  <br/>
  <br/>
  # board-minispartan-xc6slx25-ftg256-3.ucf
  <br/>
  #
  <br/>
  # Board: Scarab miniSpartan6+ Rev B
  <br/>
  # Family: Spartan-6
  <br/>
  # Device: LX25
  <br/>
  # Package: FTG256
  <br/>
  # Speed: -3
  <br/>
  <br/>
  CONFIG VCCAUX = 3.3;
  <br/>
  <br/>
  # External oscillator
  <br/>
  NET "CLOCK"                           LOC = "K3" | IOSTANDARD = LVCMOS33 | PERIOD = 50 MHz; # = 20 ns;
  <br/>
  <br/>
  # Audio I/O Pins
  <br/>
  #NET "AUDIO_OUT_LEFT"                LOC = "B8" | IOSTANDARD = LVCMOS33 | DRIVE=16 | SLEW=SLOW;
  <br/>
  #NET "AUDIO_OUT_RIGHT"               LOC = "A8" | IOSTANDARD = LVCMOS33 | DRIVE=16 | SLEW=SLOW;
  <br/>
  <br/>
  # Port A I/O Pins
  <br/>
  NET "SERIAL_RXD"                    LOC = "E7" | IOSTANDARD = LVCMOS33;
  <br/>
  NET "SERIAL_TXD"                       LOC = "C8" | IOSTANDARD = LVCMOS33 | DRIVE=16 | SLEW=SLOW;
  <br/>
  <br/>
  <br/>
  # DIP Switches
  <br/>
  #NET "SWITCH[0]"                       LOC = "L1"  | IOSTANDARD = LVCMOS33 | PULLUP;
  <br/>
  #NET "SWITCH[1]"                     LOC = "L3"  | IOSTANDARD = LVCMOS33 | PULLUP;
  <br/>
  #NET "SWITCH[2]"                     LOC = "L4"  | IOSTANDARD = LVCMOS33 | PULLUP;
  <br/>
  #NET "SWITCH[3]"                     LOC = "L5"  | IOSTANDARD = LVCMOS33 | PULLUP;
  <br/>
  <br/>
  NET "LED[0]"                        LOC = "P11" | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[1]"                        LOC = "N9"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[2]"                        LOC = "M9"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[3]"                        LOC = "P9"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[4]"                        LOC = "T8"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[5]"                        LOC = "N8"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[6]"                        LOC = "P8"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[7]"                        LOC = "P7"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  <br/>
  <br/>
  <br/>
 </body>
</html>