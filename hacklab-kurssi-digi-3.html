<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-type"/>
  <meta content="en-us" http-equiv="Content-Language"/>
  <title>
   /hacklab-kurssi-digi-3
  </title>
 </head>
 <body>
  Tämä sivu:
  <a href="./hacklab-kurssi-digi-3.html">
   https://kirjoitusalusta.fi/hacklab-kurssi-digi-3
  </a>
  <br/>
  <br/>
  <b>
   Digitaalitekniikka-3, FPGA-jatko
  </b>
  <br/>
  <br/>
  <br/>
  // Serial input, demo
  <br/>
  <br/>
  `timescale 1ns / 1ps
  <br/>
  `default_nettype none
  <br/>
  <br/>
  <br/>
  module SerialInput #(
  <br/>
  parameter                        CLOCK_FREQUENCY_HZ = 0,
  <br/>
  parameter                        BITS_PER_SECOND = 0,
  <br/>
  parameter                        TIMER_VALUE_PER_BIT = (2**15)/(CLOCK_FREQUENCY_HZ/BITS_PER_SECOND)
  <br/>
  ) (
  <br/>
  input   wire                clock,
  <br/>
  input   wire                rxd,
  <br/>
  <br/>
  output  reg     [8-1:0]     data,
  <br/>
  output  reg                 available
  <br/>
  );
  <br/>
  initial $display("SerialInput # CLOCK_FREQUENCY_HZ = %.3f, BITS_PER_SECOND = %d, TIMER_VALUE_PER_BIT = %d", CLOCK_FREQUENCY_HZ, BITS_PER_SECOND, TIMER_VALUE_PER_BIT);
  <br/>
  <br/>
  initial                     { available, data } &lt;= { 8'd0, 1'b1 };
  <br/>
  <br/>
  parameter RESET =              3'b000;
  <br/>
  parameter IDLE =            3'b001;
  <br/>
  parameter START_BIT =         3'b010;
  <br/>
  parameter DATA_BITS =       3'b011;
  <br/>
  parameter STOP_BIT =        3'b100;
  <br/>
  <br/>
  reg        [3-1:0]                state =         RESET;
  <br/>
  reg        [16-1:0]            timer =         1'd0;
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  case (state)
  <br/>
  RESET: begin
  <br/>
  timer &lt;= timer[14:0] + $unsigned(TIMER_VALUE_PER_BIT/2);
  <br/>
  if (timer[15]) begin
  <br/>
  state &lt;= IDLE;
  <br/>
  end else if (rxd == 1'b0) begin
  <br/>
  timer &lt;= 1'd0;
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  IDLE: begin
  <br/>
  if (rxd == 1'b0) begin
  <br/>
  state &lt;= START_BIT;
  <br/>
  timer &lt;= 1'd0;
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  START_BIT: begin
  <br/>
  timer &lt;= timer[14:0] + $unsigned(TIMER_VALUE_PER_BIT/2);
  <br/>
  if (timer[15]) begin
  <br/>
  if (rxd == 1'b0) begin
  <br/>
  state &lt;= DATA_BITS;
  <br/>
  end else begin
  <br/>
  state &lt;= RESET;
  <br/>
  timer &lt;= 1'd0;
  <br/>
  { available, data } &lt;= { 8'd0, 1'b1 };
  <br/>
  end
  <br/>
  end
  <br/>
  <br/>
  end
  <br/>
  <br/>
  DATA_BITS: begin
  <br/>
  timer &lt;= timer[14:0] + $unsigned(TIMER_VALUE_PER_BIT);
  <br/>
  if (timer[15]) begin
  <br/>
  if (available) begin
  <br/>
  state &lt;= RESET;
  <br/>
  timer &lt;= 1'd0;
  <br/>
  { available, data } &lt;= { 8'd0, 1'b1 };
  <br/>
  end else begin
  <br/>
  { available, data } &lt;= { data, rxd };
  <br/>
  end
  <br/>
  end
  <br/>
  end
  <br/>
  endcase
  <br/>
  end
  <br/>
  endmodule
  <br/>
  <br/>
  <br/>
  module Main #(
  <br/>
  parameter                    CLOCK_FREQUENCY_HZ = 50_000_000,
  <br/>
  parameter                    CLOCK_PERIOD_NS = 1000000000.0/CLOCK_FREQUENCY_HZ
  <br/>
  ) (
  <br/>
  input    wire                   CLOCK,
  <br/>
  <br/>
  output    reg     [7:0]             LED,
  <br/>
  <br/>
  input    wire                SERIAL_RXD
  <br/>
  //output    wire                SERIAL_TXD,
  <br/>
  );
  <br/>
  initial $display("Main # CLOCK_FREQUENCY_HZ = %.3f, CLOCK_PERIOD_NS = %.3f", CLOCK_FREQUENCY_HZ, CLOCK_PERIOD_NS);
  <br/>
  <br/>
  initial LED = 8'b01010101;
  <br/>
  <br/>
  wire     clock = CLOCK;
  <br/>
  <br/>
  <br/>
  wire    [7:0]                                rxd_data;
  <br/>
  wire    [7:0]                                rxd_available;
  <br/>
  SerialInput #(
  <br/>
  .CLOCK_FREQUENCY_HZ(CLOCK_FREQUENCY_HZ),
  <br/>
  .BITS_PER_SECOND(115200)
  <br/>
  ) (
  <br/>
  .clock(clock),
  <br/>
  .rxd(SERIAL_RXD),
  <br/>
  .data(rxd_data),
  <br/>
  .available(rxd_available)
  <br/>
  );
  <br/>
  <br/>
  always @(posedge clock) begin
  <br/>
  if (rxd_available) begin
  <br/>
  LED &lt;= rxd_data;
  <br/>
  end
  <br/>
  end
  <br/>
  endmodule
  <br/>
  <br/>
  <br/>
  <br/>
  <b>
   ----- Esimerkki UCF Minispartanille
  </b>
  <br/>
  <br/>
  # board-minispartan-xc6slx25-ftg256-3.ucf
  <br/>
  #
  <br/>
  # Board: Scarab miniSpartan6+ Rev B
  <br/>
  # Family: Spartan-6
  <br/>
  # Device: LX25
  <br/>
  # Package: FTG256
  <br/>
  # Speed: -3
  <br/>
  <br/>
  CONFIG VCCAUX = 3.3;
  <br/>
  <br/>
  # External oscillator
  <br/>
  NET "CLOCK"                           LOC = "K3" | IOSTANDARD = LVCMOS33 | PERIOD = 50 MHz; # = 20 ns;
  <br/>
  <br/>
  # Port A I/O Pins
  <br/>
  NET "SERIAL_RXD"                    LOC = "E7" | IOSTANDARD = LVCMOS33;
  <br/>
  #NET "SERIAL_TXD"                       LOC = "C8" | IOSTANDARD = LVCMOS33 | DRIVE=16 | SLEW=SLOW;
  <br/>
  <br/>
  NET "LED[0]"                        LOC = "P11" | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[1]"                        LOC = "N9"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[2]"                        LOC = "M9"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[3]"                        LOC = "P9"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[4]"                        LOC = "T8"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[5]"                        LOC = "N8"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[6]"                        LOC = "P8"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  NET "LED[7]"                        LOC = "P7"  | IOSTANDARD = LVCMOS33 | DRIVE=8 | SLEW=SLOW;
  <br/>
  <br/>
  <br/>
 </body>
</html>