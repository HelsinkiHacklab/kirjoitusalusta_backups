<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="en-us" />
<title>/hacklab-kurssit-fpga</title>
</head>
<body><b><u>dEEP FPGA -kurssia Helsinki Hacklabillä</u></b><br
/><br
/>Suovulan muistipointteja kirjasta Real World FPGA Design with Verilog:<br
/><br
/><br
/><b>Latches vs. Flipflops</b><br
/><ul><li>generally both will sample the input signal at clock egde, but latch is transparent when clock signal is low</li
><li><i><u>Transparent Latch</u></i><ul><li>Reset Set Latch, RTL: LATRS</li
><li>Verilog:<ul><li><b>always</b> @ (data_in <b>or</b> clock)</li
><li><b>if</b> (!clock) begin<ul><li>data_out &lt;= data_in;</li></ul
></li
><li><b>end</b></li></ul
></li></ul
></li
><li><i><u>D Flipflop</u></i><ul><li>Data Flip-flop with Reset and Set, RTL: DFFERS</li
><li>Verilog:<ul><li><b>always</b> @ (<b>posedge</b> clock)</li
><li><b>begin</b><ul><li>data_out &lt;= data_in;</li></ul
></li
><li><b>end</b></li></ul
></li
><li>VHDL:<ul><li>begin dff: process (D, CLK)<ul><li>begin<ul><li>if (rising_edge(CLK)) then<ul><li>Q &lt;= D;</li></ul
></li
><li>end if;</li></ul
></li></ul
></li
><li>end process dff;<br/><br
/><br/><br
/></li></ul
></li></ul
></li></ul
><b>Synchronization</b><br
/><ul><li>s.59 "Each FPGA input should drive one and exactly one flipflop."</li
><li>s.4 "Always synchronize inputs that are not phase related to the system clock."</li
><li>s.4 "Use double-synchronizing flipflops for external signals to minimize metastability problems."<ul><li>Verilog:<ul><li><b>always</b> @ (<b>posedge</b> clock)</li
><li><b>begin</b><ul><li>button_sync1 &lt;= button_in;</li
><li>button_sync2 &lt;= button_sync1;</li></ul
></li
><li><b>end</b><br/><br
/><br/><br
/></li></ul
></li></ul
></li
><li>Onko ylläolevat järkeviä päätelmiä?<ul><li>Karttu antaa hyväksyntänsä!<br/><br
/><br/><br
/></li></ul
></li></ul
><u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/><br
/><b>CPLD-ohjelmointi JTAGWhisperer-ohjelmalla</b><br
/><br
/>Esimerkit Windowsiin, mutta kaikki ohjelmat ovat saatavilla myös muihin käyttöjärjestelmiin.<br
/><br
/><i><u>1. JTAGWhisperer-ohjelma Arduinoon</u></i><br
/><br
/><ul><li>lataa JTAGWhisperer osoitteesta <a href="https://github.com/sowbug/JTAGWhisperer">https://github.com/sowbug/JTAGWhisperer</a><br/><br
/></li
><li>pura zip-paketti Arduinon libraries-hakemistoon<ul><li>purkaantuu oletuksena hakemistoon sowbug-JTAGWhisperer-0200a39, hakemiston nimi pitää muuttaa pelkäksi JTAGWhisperer:ksi</li></ul
></li></ul
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/><ul><li>Arduino IDE:ssä pitäisi nyt näkyä File-&gt;Examples-&gt;JTAGWhisperer-&gt;JTAGWhisperer<ul><li>avaa tämä, käännä ja uploadaa Arduinoon<br/><br
/><br/><br
/></li></ul
></li></ul
><i><u>2. Python-ympäristön asennus</u></i><br
/><br
/><ul><li>Lataa ja asenna Python 2.7 (ei 3.x !) sivulta&nbsp;</li></ul
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.python.org/download/">http://www.python.org/download/</a> (python-2.7.2.msi)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/><ul><li>Lataa ja asenna Pythonin sarjaporttikirjasto pyserial sivulta</li></ul
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://sourceforge.net/projects/pyserial/">http://sourceforge.net/projects/pyserial/</a> (pyserial-2.5.win32.exe)<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/><br
/><u>3<i>. Python-skriptin ja Arduinon yhteistyön testaus</u></i><br
/><br
/><ul><li>Windowsin command promptiin<br/><br
/></li
><li>Siirry JTAGWhisperer-kirjaston hakemistoon</li></ul
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C:\Users\Jari\Documents\Arduino\libraries\JTAGWhisperer<br
/>&nbsp;&nbsp;&nbsp;&nbsp;<br
/><ul><li>Anna komento (COM8 = Arduinon sarjaportin numero)</li></ul
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c:\python27\python send_xsvf -p COM8 xsvf\XC9572XL\DeviceID.xsvf<br
/>&nbsp;&nbsp;&nbsp;&nbsp;<br
/><ul><li>Homma epäonnistuu, koska ei ole CPLD:tä perässä, mutta pitäisi tulostua suunnilleen:<br/><br
/></li></ul
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ready to send file of size 90 bytes.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device is ready.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sent:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64 bytes,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 26 remaining<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPORTANT: SDR check failed.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPORTANT: Failure at instruction #7<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPORTANT: Processed 7 instructions.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPORTANT: Checksum 6c2/21.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Received device quit: Exiting!<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Expected checksum: 10c1/5a.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Elapsed time: 0.04 seconds.<br
/><br
/><ul><li>Osa näistä tulosteista tulee Arduinon ohjelmalta, joten Python-skripti ja Arduino keskustelevat.<br/><br
/><br/><br
/></li></ul
><i><u>4. CPLD:n kytkeminen Arduinoon</u></i><br
/><br
/><ul><li>Kytke piuhat Arduinosta CPLD:hen JTAGWhispererin readme.md-tiedostossa kuvatun mukaisesti:<br/><br
/></li></ul
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arduino pin&nbsp; 8 = TMS<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arduino pin&nbsp; 9 = TDI<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arduino pin 10 = TDO<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arduino pin 11 = TCK<br
/><br
/><ul><li>Myös CPLD:n ja Arduinon maat pitää kytkeä yhteen.</li></ul
>&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;<br
/><i><u>5. CPLD:n ohjelmointi</u></i><br
/><br
/><ul><li>Tee iMPACTilla XSVF-muotoinen ohjelmointitiedosto</li
><li>Ohjelmoi se sisään samalla komennolla kuin kohdassa 3</li
><li>Tuloste pitäisi olla tämän tapainen:<br/><br
/></li></ul
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ready to send file of size 103964 bytes.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device is ready.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sent:&nbsp;&nbsp; 103964 bytes,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 remaining<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPORTANT: XCOMPLETE<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPORTANT: Processed 11582 instructions.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPORTANT: Checksum 6e06ac/1961c.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Received device quit: Exiting!<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Expected checksum: 6e06ac/1961c.<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Elapsed time: 43.77 seconds.<br
/><br
/><ul><li>Rivi "IMPORTANT: XCOMPLETE" on merkki siitä, että ohjelmointi meni loppuun saakka.<br/><br
/></li></ul
>--------8&lt;----------------8&lt;----------------8&lt;----------------8&lt;----------------8&lt;--------<br
/><br
/><br
/>enum { BufferSize = 1*1024 };<br
/>uint8_t&nbsp;&nbsp;&nbsp; buffer[BufferSize];<br
/><br
/>enum {<br
/>&nbsp; SERIAL_DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 3,<br
/>&nbsp; SERIAL_CLK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 4,<br
/>&nbsp; SERIAL_ENABLE&nbsp;&nbsp;&nbsp;&nbsp; = 12,<br
/>&nbsp; SERIAL_DELAY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 10,<br
/>};<br
/><br
/>const uint8_t IntelHEXStartCode = ':';<br
/><br
/>void HALT(uint8_t) {<br
/>&nbsp;&nbsp; // Kääk -&gt; HALT<br
/>&nbsp;&nbsp; while (true) {<br
/>&nbsp;&nbsp;&nbsp;&nbsp; digitalWrite(13, LOW);<br
/>&nbsp;&nbsp;&nbsp;&nbsp; delay(500);<br
/>&nbsp;&nbsp;&nbsp;&nbsp; digitalWrite(13, HIGH);<br
/>&nbsp;&nbsp;&nbsp;&nbsp; delay(500);<br
/>&nbsp;&nbsp; }&nbsp;&nbsp;<br
/>}<br
/><br
/><br
/>void setup() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;<br
/>&nbsp; pinMode(13, OUTPUT);<br
/>&nbsp; pinMode(11, OUTPUT);<br
/>&nbsp; pinMode(SERIAL_DATA, OUTPUT);<br
/>&nbsp; pinMode(SERIAL_CLK, OUTPUT);<br
/>&nbsp; pinMode(SERIAL_ENABLE, OUTPUT);<br
/><br
/>&nbsp;&nbsp;<br
/>&nbsp; digitalWrite(13, LOW);<br
/>&nbsp;&nbsp;<br
/>&nbsp; // Test static allocation<br
/>&nbsp; for (size_t i = 0; i &lt; BufferSize; ++i) {<br
/>&nbsp;&nbsp;&nbsp; buffer[i] = 0;<br
/>&nbsp; }<br
/><br
/>&nbsp;&nbsp;<br
/>&nbsp;&nbsp;<br
/>&nbsp; Serial.begin(9600);<br
/>&nbsp; Serial.flush();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ??<br
/>&nbsp; while (Serial.available()) Serial.read();&nbsp;&nbsp; // Clear input<br
/>&nbsp;&nbsp;<br
/>&nbsp; // All Ok<br
/>&nbsp; Serial.print("OK");&nbsp;&nbsp;<br
/>&nbsp; Serial.println();&nbsp;&nbsp;<br
/>&nbsp; digitalWrite(13, HIGH);<br
/>&nbsp;&nbsp;<br
/>&nbsp;&nbsp;<br
/>&nbsp; digitalWrite(11, LOW);<br
/>&nbsp; delayMicroseconds(1);<br
/>&nbsp; digitalWrite(11, HIGH);<br
/>&nbsp;&nbsp;<br
/>&nbsp;&nbsp;<br
/><br
/>}<br
/><br
/>size_t&nbsp;&nbsp;&nbsp;&nbsp; bytesReceived = 0;<br
/><br
/>uint32_t&nbsp;&nbsp; lastPrintTime = 0;<br
/>bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dirty = false;<br
/><br
/><br
/>uint8_t readHex8() {<br
/>&nbsp; while (Serial.available() &lt; 2) { };&nbsp;<br
/>&nbsp; int h1 = Serial.read();<br
/>&nbsp; int h2 = Serial.read();<br
/><br
/>&nbsp; uint8_t val = 0;<br
/>&nbsp; if (h1 &gt;= '0' &amp;&amp; h1 &lt;= '9') val |= (h1 - '0') &lt;&lt; 4;<br
/>&nbsp; if (h1 &gt;= 'a' &amp;&amp; h1 &lt;= 'f') val |= (h1 - 'a' + 10) &lt;&lt; 4;<br
/>&nbsp; if (h1 &gt;= 'A' &amp;&amp; h1 &lt;= 'F') val |= (h1 - 'A' + 10) &lt;&lt; 4;<br
/>&nbsp; if (h2 &gt;= '0' &amp;&amp; h2 &lt;= '9') val |= (h2 - '0') &lt;&lt; 0;<br
/>&nbsp; if (h2 &gt;= 'a' &amp;&amp; h2 &lt;= 'f') val |= (h2 - 'a' + 10) &lt;&lt; 0;<br
/>&nbsp; if (h2 &gt;= 'A' &amp;&amp; h2 &lt;= 'F') val |= (h2 - 'A' + 10) &lt;&lt; 0;<br
/>&nbsp;&nbsp;<br
/>&nbsp; return val;<br
/>}<br
/><br
/>uint16_t readHex16BE() {<br
/>&nbsp; uint16_t&nbsp; b1 = readHex8();<br
/>&nbsp; uint16_t&nbsp; b2 = readHex8();<br
/><br
/>&nbsp; return (b1 &lt;&lt; 8) + b2;<br
/>}<br
/><br
/>uint32_t readHex32BE() {<br
/>&nbsp; uint32_t&nbsp; b1 = readHex8();<br
/>&nbsp; uint32_t&nbsp; b2 = readHex8();<br
/>&nbsp; uint32_t&nbsp; b3 = readHex8();<br
/>&nbsp; uint32_t&nbsp; b4 = readHex8();<br
/><br
/>&nbsp; return (b1 &lt;&lt; 24) + (b2 &lt;&lt; 16) + (b3 &lt;&lt; 8) + b4;<br
/>}<br
/><br
/><br
/><br
/><br
/>uint8_t send_serial_out(uint32_t val, size_t bits) {<br
/>&nbsp; uint8_t even_parity = 0;<br
/>&nbsp;&nbsp;<br
/>&nbsp; digitalWrite(SERIAL_CLK, LOW);<br
/>&nbsp; digitalWrite(SERIAL_ENABLE, HIGH);<br
/>&nbsp;&nbsp;<br
/>&nbsp; for(size_t i = 0; i &lt; bits; i++) {&nbsp;<br
/>&nbsp;&nbsp;&nbsp; bool bit = (val &gt;&gt; (bits - i - 1)) &amp; 0x1;<br
/>&nbsp;&nbsp;&nbsp; digitalWrite(SERIAL_DATA, bit);&nbsp; // siirretään taulukko vasemmalta oikealle&nbsp;<br
/>&nbsp;&nbsp;&nbsp; digitalWrite(SERIAL_CLK, HIGH);<br
/>&nbsp;&nbsp;&nbsp; //delay(SERIAL_DELAY);&nbsp;<br
/>&nbsp;&nbsp;&nbsp; digitalWrite(SERIAL_CLK, LOW);<br
/>&nbsp;&nbsp;&nbsp; //delay(SERIAL_DELAY);&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp; even_parity = (even_parity ^ bit) &amp; 0x01;<br
/>&nbsp; }<br
/>&nbsp; digitalWrite(SERIAL_ENABLE, LOW);<br
/>&nbsp; digitalWrite(SERIAL_CLK, LOW);<br
/>&nbsp;&nbsp;<br
/>&nbsp; return even_parity;<br
/>}<br
/><br
/><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // uint8_t send_serial_out(uint8_t table[], size_t tablesize) {<br
/><br
/><br
/><br
/>void loop() {<br
/>&nbsp;&nbsp;<br
/>&nbsp; int c = 0;<br
/>&nbsp;&nbsp;<br
/>&nbsp; if (Serial.available()) {<br
/>&nbsp;&nbsp;&nbsp; c = Serial.read();<br
/>&nbsp;&nbsp;&nbsp; if (c == IntelHEXStartCode) {<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint8_t&nbsp;&nbsp;&nbsp;&nbsp; byteCount = readHex8();<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint16_t&nbsp;&nbsp;&nbsp; address = readHex16BE();<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint8_t&nbsp;&nbsp;&nbsp;&nbsp; recordType = readHex8();<br
/><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (recordType == 00) {<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial.print("byteCount = ");&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial.print(byteCount);&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial.print(" address = ");&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial.print(address);&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial.print(" recordType = ");&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial.print(recordType);&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Data<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0; i &lt; byteCount; ++i) {<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[i] = readHex8();<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br
/><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Tässä näin..<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0; i &lt; byteCount; ++i) {<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; send_serial_out((uint32_t(address + i) &lt;&lt; 8) | buffer[i], 15+8);<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial.print(" &lt;&gt; ");&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bytesReceived += byteCount;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (recordType == 01) {<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // End Of File<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial.println("&lt;EOF&gt;");&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0; i &lt; byteCount; ++i) readHex8();<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dirty = true;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Serial.print("Unknown record");&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0; i &lt; byteCount; ++i) readHex8();<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br
/><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint8_t&nbsp;&nbsp;&nbsp; checksum = readHex8();<br
/><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial.print(" checksum = ");&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial.print(int(checksum));&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial.println();&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br
/>&nbsp;&nbsp;&nbsp; } else {<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Skip&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Serial.print("unknown char = ");&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Serial.print(int(c));&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Serial.println();&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp; }<br
/>&nbsp; }<br
/>&nbsp;&nbsp;<br
/>&nbsp; if (dirty &amp;&amp; (millis() - lastPrintTime) &gt; 5000) {<br
/>&nbsp;&nbsp;&nbsp; Serial.print("OK ");&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp; Serial.print(bytesReceived);&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp; Serial.print(" bytes received");&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp; Serial.println();&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp;&nbsp;&nbsp; lastPrintTime = millis();<br
/>&nbsp;&nbsp;&nbsp; dirty = false;<br
/>&nbsp;&nbsp;&nbsp;&nbsp;<br
/>&nbsp; }<br
/>&nbsp;<br
/>&nbsp;&nbsp;<br
/>&nbsp;&nbsp;<br
/>}<br
/><br
/><br
/><br
/></body>
</html>
